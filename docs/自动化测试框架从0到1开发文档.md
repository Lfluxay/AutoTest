# è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶ä» 0 åˆ° 1 å®Œæ•´å¼€å‘æ–‡æ¡£

## ğŸ“š æ–‡æ¡£ç›®å½•

- [1. æ¡†æ¶æ¦‚è¿°ä¸è®¾è®¡ç†å¿µ](#1-æ¡†æ¶æ¦‚è¿°ä¸è®¾è®¡ç†å¿µ)
- [2. æŠ€æœ¯æ¶æ„è®¾è®¡](#2-æŠ€æœ¯æ¶æ„è®¾è®¡)
- [3. æ ¸å¿ƒæ¨¡å—è¯¦è§£](#3-æ ¸å¿ƒæ¨¡å—è¯¦è§£)
- [4. é…ç½®ç³»ç»Ÿè®¾è®¡](#4-é…ç½®ç³»ç»Ÿè®¾è®¡)
- [5. ç”¨ä¾‹æ‰§è¡Œå¼•æ“](#5-ç”¨ä¾‹æ‰§è¡Œå¼•æ“)
- [6. å…³é”®å­—é©±åŠ¨å®ç°](#6-å…³é”®å­—é©±åŠ¨å®ç°)
- [7. æŠ¥å‘Šä¸é€šçŸ¥ç³»ç»Ÿ](#7-æŠ¥å‘Šä¸é€šçŸ¥ç³»ç»Ÿ)
- [8. æ‰©å±•å¼€å‘æŒ‡å—](#8-æ‰©å±•å¼€å‘æŒ‡å—)
- [9. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#9-æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [10. æœ€ä½³å®è·µä¸è§„èŒƒ](#10-æœ€ä½³å®è·µä¸è§„èŒƒ)
- [11. è‡ªå®šä¹‰æ¡†æ¶å¼€å‘æŒ‡å—](#11-è‡ªå®šä¹‰æ¡†æ¶å¼€å‘æŒ‡å—)
- [12. æ¡†æ¶æ¼”è¿›ä¸ç»´æŠ¤](#12-æ¡†æ¶æ¼”è¿›ä¸ç»´æŠ¤)
- [13. å®‰å…¨ä¸åˆè§„è€ƒè™‘](#13-å®‰å…¨ä¸åˆè§„è€ƒè™‘)

---

## 1. æ¡†æ¶æ¦‚è¿°ä¸è®¾è®¡ç†å¿µ

### 1.1 æ¡†æ¶å®šä½

æœ¬æ¡†æ¶æ˜¯ä¸€ä¸ª**ä¼ä¸šçº§è‡ªåŠ¨åŒ–æµ‹è¯•è§£å†³æ–¹æ¡ˆ**ï¼Œä¸“ä¸ºç°ä»£è½¯ä»¶å¼€å‘å›¢é˜Ÿè®¾è®¡ï¼Œå…·å¤‡ä»¥ä¸‹æ ¸å¿ƒä»·å€¼ï¼š

```
ğŸ¯ ä¸šåŠ¡ä»·å€¼
â”œâ”€â”€ æå‡æµ‹è¯•æ•ˆç‡ - è‡ªåŠ¨åŒ–æ‰§è¡Œï¼Œå‡å°‘äººå·¥æˆæœ¬
â”œâ”€â”€ ä¿è¯äº§å“è´¨é‡ - å…¨é¢è¦†ç›–ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
â”œâ”€â”€ åŠ é€Ÿäº¤ä»˜å‘¨æœŸ - å¿«é€Ÿåé¦ˆï¼Œæ”¯æŒæŒç»­é›†æˆ
â””â”€â”€ é™ä½ç»´æŠ¤æˆæœ¬ - å…³é”®å­—é©±åŠ¨ï¼Œæ˜“äºç»´æŠ¤

ğŸ”§ æŠ€æœ¯ä»·å€¼
â”œâ”€â”€ ç»Ÿä¸€æµ‹è¯•æ ‡å‡† - è§„èŒƒåŒ–æµ‹è¯•æµç¨‹å’Œç”¨ä¾‹æ ¼å¼
â”œâ”€â”€ æé«˜ä»£ç å¤ç”¨ - æ¨¡å—åŒ–è®¾è®¡ï¼Œç»„ä»¶å¯å¤ç”¨
â”œâ”€â”€ æ”¯æŒå›¢é˜Ÿåä½œ - å¤šäººå¹¶è¡Œå¼€å‘ï¼Œç‰ˆæœ¬æ§åˆ¶å‹å¥½
â””â”€â”€ ä¾¿äºæŠ€æœ¯ä¼ æ‰¿ - æ–‡æ¡£å®Œå–„ï¼Œå­¦ä¹ æˆæœ¬ä½
```

### 1.2 è®¾è®¡åŸåˆ™

#### 1.2.1 SOLID åŸåˆ™åº”ç”¨

```python
# å•ä¸€èŒè´£åŸåˆ™ (SRP) - æ¯ä¸ªç±»åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½
class APIClient:
    """ä¸“é—¨è´Ÿè´£HTTPè¯·æ±‚å¤„ç†"""
    def send_request(self, method, url, **kwargs):
        pass

class AssertionHelper:
    """ä¸“é—¨è´Ÿè´£æ–­è¨€éªŒè¯"""
    def assert_status_code(self, response, expected):
        pass

# å¼€é—­åŸåˆ™ (OCP) - å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
class KeywordBase:
    """å…³é”®å­—åŸºç±»ï¼Œæ”¯æŒæ‰©å±•æ–°å…³é”®å­—"""
    def execute(self, action, params):
        method = getattr(self, f"_{action}", None)
        if method:
            return method(params)
        raise NotImplementedError(f"å…³é”®å­— {action} æœªå®ç°")

# ä¾èµ–å€’ç½®åŸåˆ™ (DIP) - ä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°
class TestExecutor:
    def __init__(self, data_parser: DataParserInterface):
        self.data_parser = data_parser  # ä¾èµ–æŠ½è±¡æ¥å£
```

#### 1.2.2 è®¾è®¡æ¨¡å¼åº”ç”¨

```python
# 1. å·¥å‚æ¨¡å¼ - åˆ›å»ºä¸åŒç±»å‹çš„æµ‹è¯•æ‰§è¡Œå™¨
class TestExecutorFactory:
    @staticmethod
    def create_executor(test_type: str):
        if test_type == "api":
            return APITestExecutor()
        elif test_type == "web":
            return WebTestExecutor()
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æµ‹è¯•ç±»å‹: {test_type}")

# 2. ç­–ç•¥æ¨¡å¼ - ä¸åŒçš„æŠ¥å‘Šç”Ÿæˆç­–ç•¥
class ReportStrategy:
    def generate(self, test_results): pass

class AllureReportStrategy(ReportStrategy):
    def generate(self, test_results):
        # AllureæŠ¥å‘Šç”Ÿæˆé€»è¾‘
        pass

class HTMLReportStrategy(ReportStrategy):
    def generate(self, test_results):
        # HTMLæŠ¥å‘Šç”Ÿæˆé€»è¾‘
        pass

# 3. è§‚å¯Ÿè€…æ¨¡å¼ - æµ‹è¯•äº‹ä»¶é€šçŸ¥
class TestEventObserver:
    def on_test_start(self, test_case): pass
    def on_test_end(self, test_case, result): pass

class NotificationObserver(TestEventObserver):
    def on_test_end(self, test_case, result):
        if result.failed:
            self.send_failure_notification(test_case, result)
```

### 1.3 æ ¸å¿ƒç‰¹æ€§

#### 1.3.1 å…³é”®å­—é©±åŠ¨æ¶æ„

```yaml
# ç”¨ä¾‹ç¼–å†™ç¤ºä¾‹ - æ— éœ€ç¼–ç¨‹çŸ¥è¯†
test_cases:
  - case_name: "ç”¨æˆ·ç™»å½•æµ‹è¯•"
    steps:
      - action: "send_request"
        params:
          method: "POST"
          url: "/api/login"
          data:
            username: "admin"
            password: "123456"
      - action: "assert_status_code"
        params:
          expected: 200
      - action: "extract_data"
        params:
          name: "token"
          path: "$.data.token"
```

#### 1.3.2 å¤šå±‚é…ç½®ç®¡ç†

```
é…ç½®å±‚æ¬¡ç»“æ„ï¼š
â”œâ”€â”€ æ ¸å¿ƒé…ç½® (config.yaml)
â”‚   â”œâ”€â”€ æ¡†æ¶åŸºç¡€è®¾ç½®
â”‚   â”œâ”€â”€ æ‰§è¡Œæ¨¡å¼é…ç½®
â”‚   â””â”€â”€ æ—¥å¿—æŠ¥å‘Šé…ç½®
â”œâ”€â”€ ç¯å¢ƒé…ç½® (environments.yaml)
â”‚   â”œâ”€â”€ å¼€å‘ç¯å¢ƒé…ç½®
â”‚   â”œâ”€â”€ æµ‹è¯•ç¯å¢ƒé…ç½®
â”‚   â””â”€â”€ ç”Ÿäº§ç¯å¢ƒé…ç½®
â””â”€â”€ æµ‹è¯•è®¾ç½® (test_settings.yaml)
    â”œâ”€â”€ ç”¨ä¾‹ç­›é€‰è§„åˆ™
    â”œâ”€â”€ æ•°æ®é©±åŠ¨é…ç½®
    â””â”€â”€ æ‰§è¡Œç­–ç•¥è®¾ç½®
```

#### 1.3.3 å¹¶å‘æ‰§è¡Œå¼•æ“

```python
# æ™ºèƒ½å¹¶å‘è°ƒåº¦
class ConcurrentExecutor:
    def __init__(self):
        self.api_pool = ThreadPoolExecutor(max_workers=4)
        self.web_pool = ThreadPoolExecutor(max_workers=2)

    def execute_tests(self, test_cases):
        # æ ¹æ®æµ‹è¯•ç±»å‹åˆ†é…åˆ°ä¸åŒçº¿ç¨‹æ± 
        api_futures = []
        web_futures = []

        for case in test_cases:
            if case.test_type == "api":
                future = self.api_pool.submit(self.execute_api_test, case)
                api_futures.append(future)
            elif case.test_type == "web":
                future = self.web_pool.submit(self.execute_web_test, case)
                web_futures.append(future)

        # ç­‰å¾…æ‰€æœ‰æµ‹è¯•å®Œæˆ
        return self.collect_results(api_futures + web_futures)
```

---

## 2. æŠ€æœ¯æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ·äº¤äº’å±‚ (User Interface)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‘½ä»¤è¡Œæ¥å£ â”‚  é…ç½®æ–‡ä»¶  â”‚  æµ‹è¯•ç”¨ä¾‹æ–‡ä»¶  â”‚  æŠ¥å‘ŠæŸ¥çœ‹å™¨      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨æœåŠ¡å±‚ (Application Layer)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TestFrameworkApp â”‚ ArgumentParser â”‚ ReportGenerator â”‚ NotificationSender â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  TestExecutor â”‚ CaseParser â”‚ KeywordEngine â”‚ AssertionEngine â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ ¸å¿ƒæœåŠ¡å±‚ (Core Service Layer)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  APIClient â”‚ WebDriver â”‚ DatabaseHelper â”‚ DataExtractor â”‚ Logger â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ConfigManager â”‚ FileSystem â”‚ NetworkIO â”‚ ProcessManager â”‚ ThreadPool â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ¨¡å—ä¾èµ–å…³ç³»

```python
# ä¾èµ–æ³¨å…¥å®¹å™¨è®¾è®¡
class DIContainer:
    def __init__(self):
        self._services = {}
        self._singletons = {}

    def register(self, interface, implementation, singleton=False):
        """æ³¨å†ŒæœåŠ¡"""
        self._services[interface] = {
            'implementation': implementation,
            'singleton': singleton
        }

    def get(self, interface):
        """è·å–æœåŠ¡å®ä¾‹"""
        service_info = self._services.get(interface)
        if not service_info:
            raise ValueError(f"æœåŠ¡ {interface} æœªæ³¨å†Œ")

        if service_info['singleton']:
            if interface not in self._singletons:
                self._singletons[interface] = service_info['implementation']()
            return self._singletons[interface]

        return service_info['implementation']()

# æœåŠ¡æ³¨å†Œ
container = DIContainer()
container.register('config_manager', UnifiedConfigManager, singleton=True)
container.register('logger', Logger, singleton=True)
container.register('api_client', APIClient)
container.register('web_driver', WebDriver)
```

### 2.3 æ•°æ®æµè®¾è®¡

```
æµ‹è¯•æ‰§è¡Œæ•°æ®æµï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨ä¾‹æ–‡ä»¶    â”‚â”€â”€â”€â–¶â”‚  è§£æå™¨      â”‚â”€â”€â”€â–¶â”‚  æ‰§è¡Œå¼•æ“    â”‚
â”‚ (YAML/Excel)â”‚    â”‚ (Parser)    â”‚    â”‚ (Executor)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æµ‹è¯•æŠ¥å‘Š    â”‚â—€â”€â”€â”€â”‚  ç»“æœæ”¶é›†å™¨  â”‚â—€â”€â”€â”€â”‚  å…³é”®å­—å¼•æ“  â”‚
â”‚ (Report)    â”‚    â”‚ (Collector) â”‚    â”‚ (Keywords)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 3.1 é…ç½®ç®¡ç†æ¨¡å— (UnifiedConfigManager)

#### 3.1.1 è®¾è®¡ç›®æ ‡

```python
"""
é…ç½®ç®¡ç†æ¨¡å—è®¾è®¡ç›®æ ‡ï¼š
1. ç»Ÿä¸€é…ç½®å…¥å£ - æ‰€æœ‰é…ç½®é€šè¿‡ç»Ÿä¸€æ¥å£è®¿é—®
2. åˆ†å±‚é…ç½®ç®¡ç† - æ”¯æŒå¤šå±‚é…ç½®è¦†ç›–
3. åŠ¨æ€é…ç½®æ›´æ–° - æ”¯æŒé…ç½®æ–‡ä»¶çƒ­æ›´æ–°
4. ç¯å¢ƒéš”ç¦» - ä¸åŒç¯å¢ƒä½¿ç”¨ä¸åŒé…ç½®
5. é…ç½®éªŒè¯ - ç¡®ä¿é…ç½®çš„æ­£ç¡®æ€§å’Œå®Œæ•´æ€§
"""

class UnifiedConfigManager:
    """ç»Ÿä¸€é…ç½®ç®¡ç†å™¨ - æ¡†æ¶é…ç½®çš„æ ¸å¿ƒ"""

    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
        self.current_env = os.getenv('ENV', 'dev')
        self._config_cache = {}
        self._file_cache = {}
        self._file_timestamps = {}
        self._lock = threading.RLock()

        # å¯åŠ¨é…ç½®æ–‡ä»¶ç›‘æ§
        self._setup_file_watcher()

        # åŠ è½½æ‰€æœ‰é…ç½®æ–‡ä»¶
        self._load_all_configs()
```

#### 3.1.2 é…ç½®åŠ è½½æœºåˆ¶

```python
def _load_all_configs(self):
    """åŠ è½½æ‰€æœ‰é…ç½®æ–‡ä»¶"""
    config_files = {
        'main': 'config.yaml',
        'test_settings': 'test_settings.yaml',
        'environments': 'environments.yaml'
    }

    for key, filename in config_files.items():
        file_path = self.config_dir / filename
        if file_path.exists():
            self._load_config_file(key, file_path)
        else:
            logger.warning(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
            self._file_cache[key] = {}

def _load_config_file(self, key: str, file_path: Path):
    """åŠ è½½å•ä¸ªé…ç½®æ–‡ä»¶"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f) or {}

        # å¤„ç†ç¯å¢ƒé…ç½®æ–‡ä»¶
        if key == 'environments':
            for env_name, env_config in config_data.items():
                self._file_cache[f'env_{env_name}'] = env_config
        else:
            self._file_cache[key] = config_data

        # è®°å½•æ–‡ä»¶æ—¶é—´æˆ³
        self._file_timestamps[str(file_path)] = file_path.stat().st_mtime

        logger.debug(f"é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ: {file_path}")

    except Exception as e:
        logger.error(f"é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥: {file_path}, é”™è¯¯: {e}")
        self._file_cache[key] = {}
```

#### 3.1.3 é…ç½®åˆå¹¶ç­–ç•¥

````python
def get_merged_config(self, env: Optional[str] = None) -> Dict[str, Any]:
    """
    è·å–åˆå¹¶åçš„é…ç½®
    åˆå¹¶é¡ºåºï¼šä¸»é…ç½® -> æµ‹è¯•è®¾ç½®é…ç½® -> ç¯å¢ƒé…ç½®
    """
    env = env or self.current_env
    cache_key = f"merged:{env}"

    with self._lock:
        if cache_key in self._config_cache:
            return self._config_cache[cache_key]

    # è·å–å„å±‚é…ç½®
    main_config = self._file_cache.get('main', {}).copy()
    test_settings_config = self._file_cache.get('test_settings', {})
    env_config = self._file_cache.get(f'env_{env}', {})

    # æ·±åº¦åˆå¹¶é…ç½®
    merged = self._deep_merge(main_config, test_settings_config)
    merged = self._deep_merge(merged, env_config)

    # ç¼“å­˜ç»“æœ
    with self._lock:
        self._config_cache[cache_key] = merged

    return merged

def _deep_merge(self, base: Dict, override: Dict) -> Dict:
    """æ·±åº¦åˆå¹¶å­—å…¸"""
    result = base.copy()

    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = self._deep_merge(result[key], value)
        else:
            result[key] = value

    return result

### 3.2 æ•°æ®è§£ææ¨¡å— (DataParser)

#### 3.2.1 å¤šæ ¼å¼æ”¯æŒè®¾è®¡

```python
class DataParser:
    """æ•°æ®è§£æå™¨ - æ”¯æŒYAMLå’ŒExcelæ ¼å¼"""

    def __init__(self):
        self.template_parser = TemplateParser()
        self.faker_helper = FakerHelper()

    def parse_yaml(self, file_path: str) -> Dict[str, Any]:
        """è§£æYAMLæ ¼å¼æµ‹è¯•ç”¨ä¾‹"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # å¤„ç†æ¨¡æ¿å˜é‡
            content = self._process_template_variables(content)

            # è§£æYAML
            data = yaml.safe_load(content)

            # éªŒè¯æ•°æ®æ ¼å¼
            if self._validate_test_data(data):
                return data
            else:
                raise ValueError("æµ‹è¯•ç”¨ä¾‹æ ¼å¼éªŒè¯å¤±è´¥")

        except Exception as e:
            logger.error(f"YAMLæ–‡ä»¶è§£æå¤±è´¥: {file_path}, é”™è¯¯: {e}")
            return {}

    def parse_excel(self, file_path: str) -> Dict[str, Any]:
        """è§£æExcelæ ¼å¼æµ‹è¯•ç”¨ä¾‹"""
        try:
            workbook = openpyxl.load_workbook(file_path)

            # è§£ææµ‹è¯•ä¿¡æ¯å·¥ä½œè¡¨
            test_info = self._parse_test_info_sheet(workbook)

            # è§£ææµ‹è¯•ç”¨ä¾‹å·¥ä½œè¡¨
            test_cases = self._parse_test_cases_sheet(workbook)

            return {
                'test_info': test_info,
                'test_cases': test_cases
            }

        except Exception as e:
            logger.error(f"Excelæ–‡ä»¶è§£æå¤±è´¥: {file_path}, é”™è¯¯: {e}")
            return {}
````

#### 3.2.2 æ¨¡æ¿åŒ–ç”¨ä¾‹å¤„ç†

```python
def _process_template_cases(self, test_data: Dict, case_filter: Dict, file_path: str) -> List[Dict]:
    """å¤„ç†æ¨¡æ¿åŒ–ç”¨ä¾‹"""
    template_parser = TemplateParser()
    test_cases = test_data.get('test_cases', [])
    all_generated_cases = []

    for case_config in test_cases:
        if isinstance(case_config, dict):
            if 'template' in case_config:
                # æ¨¡æ¿åŒ–ç”¨ä¾‹ç”Ÿæˆ
                try:
                    generated_cases = template_parser.generate_test_cases(case_config, file_path)
                    all_generated_cases.extend(generated_cases)
                    logger.info(f"æ¨¡æ¿ç”¨ä¾‹ç”ŸæˆæˆåŠŸ: {case_config.get('case_name', 'Unknown')}, ç”Ÿæˆ {len(generated_cases)} ä¸ªç”¨ä¾‹")
                except Exception as e:
                    logger.error(f"æ¨¡æ¿ç”¨ä¾‹ç”Ÿæˆå¤±è´¥: {case_config.get('case_name', 'Unknown')}, é”™è¯¯: {e}")
            else:
                # ä¼ ç»Ÿç”¨ä¾‹
                all_generated_cases.append(case_config)

    # åº”ç”¨è¿‡æ»¤æ¡ä»¶
    if case_filter:
        all_generated_cases = self._filter_test_cases(all_generated_cases, case_filter)

    return all_generated_cases

def _process_template_variables(self, content: str) -> str:
    """å¤„ç†æ¨¡æ¿å˜é‡"""
    # å¤„ç†Fakerå˜é‡
    faker_pattern = r'\{\{\s*faker\.(\w+)(?:\(([^)]*)\))?\s*\}\}'

    def replace_faker(match):
        method_name = match.group(1)
        args_str = match.group(2) or ''

        try:
            # è§£æå‚æ•°
            args = []
            kwargs = {}
            if args_str:
                # ç®€å•çš„å‚æ•°è§£æ
                for arg in args_str.split(','):
                    arg = arg.strip()
                    if '=' in arg:
                        key, value = arg.split('=', 1)
                        kwargs[key.strip()] = eval(value.strip())
                    else:
                        args.append(eval(arg))

            # è°ƒç”¨Fakeræ–¹æ³•
            faker_value = self.faker_helper.generate(method_name, *args, **kwargs)
            return str(faker_value)

        except Exception as e:
            logger.warning(f"Fakerå˜é‡å¤„ç†å¤±è´¥: {match.group(0)}, é”™è¯¯: {e}")
            return match.group(0)

    content = re.sub(faker_pattern, replace_faker, content)

    # å¤„ç†ç¯å¢ƒå˜é‡
    env_pattern = r'\{\{\s*env\.(\w+)\s*\}\}'

    def replace_env(match):
        env_var = match.group(1)
        return os.getenv(env_var, match.group(0))

    content = re.sub(env_pattern, replace_env, content)

    return content
```

### 3.3 æµ‹è¯•æ‰§è¡Œå¼•æ“ (TestExecutor)

#### 3.3.1 æ‰§è¡Œå™¨æ¶æ„è®¾è®¡

```python
class TestExecutor:
    """æµ‹è¯•æ‰§è¡Œå™¨ - æ¡†æ¶çš„æ‰§è¡Œæ ¸å¿ƒ"""

    def __init__(self):
        self.config_manager = unified_config
        self.data_parser = DataParser()
        self.api_keywords = APIKeywords()
        self.web_keywords = WebKeywords()
        self.assertion_helper = AssertionHelper()
        self.data_extractor = DataExtractor()
        self.performance_monitor = PerformanceMonitor()

        # æ‰§è¡Œä¸Šä¸‹æ–‡
        self.execution_context = ExecutionContext()

        # äº‹ä»¶ç›‘å¬å™¨
        self.event_listeners = []

    def execute_test_case(self, test_case: Dict[str, Any]) -> TestResult:
        """æ‰§è¡Œå•ä¸ªæµ‹è¯•ç”¨ä¾‹"""
        case_name = test_case.get('case_name', 'Unknown')

        # åˆ›å»ºæµ‹è¯•ç»“æœå¯¹è±¡
        result = TestResult(case_name)

        try:
            # è§¦å‘æµ‹è¯•å¼€å§‹äº‹ä»¶
            self._notify_test_start(test_case)

            # æ€§èƒ½ç›‘æ§å¼€å§‹
            self.performance_monitor.start_monitoring(case_name)

            # æ‰§è¡Œæµ‹è¯•æ­¥éª¤
            if 'request' in test_case:
                # APIæµ‹è¯•ç”¨ä¾‹
                result = self._execute_api_test(test_case, result)
            elif 'steps' in test_case:
                # Webæµ‹è¯•ç”¨ä¾‹æˆ–æ­¥éª¤åŒ–APIæµ‹è¯•
                result = self._execute_step_test(test_case, result)
            else:
                raise ValueError("æ— æ•ˆçš„æµ‹è¯•ç”¨ä¾‹æ ¼å¼")

            # æ‰§è¡Œæ–­è¨€
            if 'assertions' in test_case:
                self._execute_assertions(test_case['assertions'], result)

            # æ•°æ®æå–
            if 'extract' in test_case:
                self._execute_extractions(test_case['extract'], result)

            result.status = TestStatus.PASSED

        except Exception as e:
            result.status = TestStatus.FAILED
            result.error_message = str(e)
            result.exception = e
            logger.error(f"æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œå¤±è´¥: {case_name}, é”™è¯¯: {e}")

        finally:
            # æ€§èƒ½ç›‘æ§ç»“æŸ
            performance_data = self.performance_monitor.stop_monitoring(case_name)
            result.performance_data = performance_data

            # è§¦å‘æµ‹è¯•ç»“æŸäº‹ä»¶
            self._notify_test_end(test_case, result)

        return result
```

#### 3.3.2 API æµ‹è¯•æ‰§è¡Œé€»è¾‘

```python
def _execute_api_test(self, test_case: Dict, result: TestResult) -> TestResult:
    """æ‰§è¡ŒAPIæµ‹è¯•ç”¨ä¾‹"""
    request_config = test_case['request']

    # æ„å»ºè¯·æ±‚å‚æ•°
    method = request_config.get('method', 'GET').upper()
    url = request_config.get('url')
    headers = request_config.get('headers', {})
    params = request_config.get('params', {})
    data = request_config.get('data')
    json_data = request_config.get('json')
    files = request_config.get('files')

    # å¤„ç†URL
    if not url.startswith('http'):
        base_url = self.config_manager.get_config('api.base_url', '')
        url = f"{base_url.rstrip('/')}/{url.lstrip('/')}"

    # å¤„ç†è®¤è¯
    auth_config = self.config_manager.get_config('api.auth')
    if auth_config and auth_config.get('enabled'):
        headers.update(self._get_auth_headers(auth_config))

    # å‘é€è¯·æ±‚
    try:
        response = self.api_keywords.send_request(
            method=method,
            url=url,
            headers=headers,
            params=params,
            data=data,
            json=json_data,
            files=files
        )

        # ä¿å­˜å“åº”åˆ°ç»“æœ
        result.response = response
        result.request_info = {
            'method': method,
            'url': url,
            'headers': headers,
            'params': params,
            'data': data,
            'json': json_data
        }

        logger.info(f"APIè¯·æ±‚æˆåŠŸ: {method} {url}, çŠ¶æ€ç : {response.status_code}")

    except Exception as e:
        raise Exception(f"APIè¯·æ±‚å¤±è´¥: {e}")

    return result

def _execute_step_test(self, test_case: Dict, result: TestResult) -> TestResult:
    """æ‰§è¡Œæ­¥éª¤åŒ–æµ‹è¯•ç”¨ä¾‹"""
    steps = test_case.get('steps', [])
    step_results = []

    for i, step in enumerate(steps):
        step_name = step.get('name', f'Step {i+1}')
        action = step.get('action')
        params = step.get('params', {})

        try:
            logger.info(f"æ‰§è¡Œæ­¥éª¤: {step_name} - {action}")

            # æ ¹æ®åŠ¨ä½œç±»å‹é€‰æ‹©æ‰§è¡Œå™¨
            if action in ['send_request', 'get', 'post', 'put', 'delete']:
                step_result = self._execute_api_step(action, params)
            elif action in ['navigate', 'click', 'input', 'wait', 'scroll']:
                step_result = self._execute_web_step(action, params)
            else:
                # å°è¯•ä»å…³é”®å­—å¼•æ“æ‰§è¡Œ
                step_result = self._execute_custom_step(action, params)

            step_results.append({
                'name': step_name,
                'action': action,
                'params': params,
                'result': step_result,
                'status': 'passed'
            })

        except Exception as e:
            step_results.append({
                'name': step_name,
                'action': action,
                'params': params,
                'error': str(e),
                'status': 'failed'
            })
            raise Exception(f"æ­¥éª¤æ‰§è¡Œå¤±è´¥: {step_name} - {e}")

    result.step_results = step_results
    return result
```

---

## 4. é…ç½®ç³»ç»Ÿè®¾è®¡

### 4.1 åˆ†å±‚é…ç½®æ¶æ„

```python
"""
é…ç½®ç³»ç»Ÿåˆ†å±‚è®¾è®¡ï¼š

Layer 1: é»˜è®¤é…ç½® (æ¡†æ¶å†…ç½®)
â”œâ”€â”€ åŸºç¡€æ¡†æ¶é…ç½®
â”œâ”€â”€ é»˜è®¤è¶…æ—¶è®¾ç½®
â””â”€â”€ æ ‡å‡†æ—¥å¿—æ ¼å¼

Layer 2: ä¸»é…ç½®æ–‡ä»¶ (config.yaml)
â”œâ”€â”€ æ¡†æ¶æ ¸å¿ƒé…ç½®
â”œâ”€â”€ æ‰§è¡Œæ¨¡å¼è®¾ç½®
â””â”€â”€ æŠ¥å‘Šé€šçŸ¥é…ç½®

Layer 3: æµ‹è¯•è®¾ç½® (test_settings.yaml)
â”œâ”€â”€ ç”¨ä¾‹ç­›é€‰è§„åˆ™
â”œâ”€â”€ æ•°æ®é©±åŠ¨é…ç½®
â””â”€â”€ æ‰§è¡Œç­–ç•¥è®¾ç½®

Layer 4: ç¯å¢ƒé…ç½® (environments.yaml)
â”œâ”€â”€ å¼€å‘ç¯å¢ƒé…ç½®
â”œâ”€â”€ æµ‹è¯•ç¯å¢ƒé…ç½®
â””â”€â”€ ç”Ÿäº§ç¯å¢ƒé…ç½®

Layer 5: è¿è¡Œæ—¶é…ç½® (å‘½ä»¤è¡Œå‚æ•°)
â”œâ”€â”€ ä¸´æ—¶è¦†ç›–é…ç½®
â”œâ”€â”€ è°ƒè¯•æ¨¡å¼è®¾ç½®
â””â”€â”€ ç‰¹æ®Šæ‰§è¡Œå‚æ•°
"""

class ConfigurationLayer:
    """é…ç½®å±‚æŠ½è±¡åŸºç±»"""

    def __init__(self, priority: int):
        self.priority = priority  # ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜
        self.config_data = {}

    def load_config(self) -> Dict[str, Any]:
        """åŠ è½½é…ç½®æ•°æ®"""
        raise NotImplementedError

    def get_config(self, key_path: str, default: Any = None) -> Any:
        """è·å–é…ç½®é¡¹"""
        return self._get_nested_value(self.config_data, key_path, default)

    def _get_nested_value(self, data: Dict, key_path: str, default: Any) -> Any:
        """è·å–åµŒå¥—å­—å…¸å€¼"""
        keys = key_path.split('.')
        current = data

        for key in keys:
            if isinstance(current, dict) and key in current:
                current = current[key]
            else:
                return default

        return current

class FileConfigLayer(ConfigurationLayer):
    """æ–‡ä»¶é…ç½®å±‚"""

    def __init__(self, file_path: str, priority: int):
        super().__init__(priority)
        self.file_path = file_path
        self.load_config()

    def load_config(self) -> Dict[str, Any]:
        """ä»æ–‡ä»¶åŠ è½½é…ç½®"""
        try:
            with open(self.file_path, 'r', encoding='utf-8') as f:
                self.config_data = yaml.safe_load(f) or {}
            logger.debug(f"é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ: {self.file_path}")
        except Exception as e:
            logger.warning(f"é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥: {self.file_path}, é”™è¯¯: {e}")
            self.config_data = {}

        return self.config_data

class EnvironmentConfigLayer(ConfigurationLayer):
    """ç¯å¢ƒå˜é‡é…ç½®å±‚"""

    def __init__(self, priority: int):
        super().__init__(priority)
        self.load_config()

    def load_config(self) -> Dict[str, Any]:
        """ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®"""
        env_config = {}

        # æ‰«æç‰¹å®šå‰ç¼€çš„ç¯å¢ƒå˜é‡
        for key, value in os.environ.items():
            if key.startswith('AUTOTEST_'):
                # è½¬æ¢ç¯å¢ƒå˜é‡åä¸ºé…ç½®è·¯å¾„
                config_key = key[9:].lower().replace('_', '.')
                env_config[config_key] = self._parse_env_value(value)

        self.config_data = env_config
        return self.config_data

    def _parse_env_value(self, value: str) -> Any:
        """è§£æç¯å¢ƒå˜é‡å€¼"""
        # å°è¯•è§£æä¸ºJSON
        try:
            return json.loads(value)
        except:
            pass

        # å°è¯•è§£æä¸ºå¸ƒå°”å€¼
        if value.lower() in ('true', 'false'):
            return value.lower() == 'true'

        # å°è¯•è§£æä¸ºæ•°å­—
        try:
            if '.' in value:
                return float(value)
            else:
                return int(value)
        except:
            pass

        # è¿”å›å­—ç¬¦ä¸²
        return value
```

### 4.2 é…ç½®éªŒè¯ä¸æ ¡éªŒ

```python
class ConfigValidator:
    """é…ç½®éªŒè¯å™¨"""

    def __init__(self):
        self.validation_rules = self._load_validation_rules()

    def validate_config(self, config: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """éªŒè¯é…ç½®çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§"""
        errors = []

        # å¿…éœ€é…ç½®é¡¹æ£€æŸ¥
        required_configs = [
            'test_type',
            'execution.concurrent.max_workers',
            'report.type',
            'logging.level'
        ]

        for required_key in required_configs:
            if not self._config_exists(config, required_key):
                errors.append(f"ç¼ºå°‘å¿…éœ€é…ç½®é¡¹: {required_key}")

        # é…ç½®å€¼èŒƒå›´æ£€æŸ¥
        range_validations = {
            'execution.concurrent.max_workers': (1, 20),
            'execution.concurrent.timeout': (10, 3600),
            'report.keep_last': (1, 100)
        }

        for key, (min_val, max_val) in range_validations.items():
            value = self._get_nested_value(config, key)
            if value is not None:
                if not isinstance(value, (int, float)) or not (min_val <= value <= max_val):
                    errors.append(f"é…ç½®é¡¹ {key} å€¼ {value} è¶…å‡ºæœ‰æ•ˆèŒƒå›´ [{min_val}, {max_val}]")

        # æšä¸¾å€¼æ£€æŸ¥
        enum_validations = {
            'test_type': ['api', 'web', 'both'],
            'report.type': ['allure', 'pytest-html', 'both'],
            'logging.level': ['DEBUG', 'INFO', 'WARNING', 'ERROR']
        }

        for key, valid_values in enum_validations.items():
            value = self._get_nested_value(config, key)
            if value is not None and value not in valid_values:
                errors.append(f"é…ç½®é¡¹ {key} å€¼ {value} ä¸åœ¨æœ‰æ•ˆé€‰é¡¹ä¸­: {valid_values}")

        # ä¾èµ–å…³ç³»æ£€æŸ¥
        self._validate_dependencies(config, errors)

        return len(errors) == 0, errors

    def _validate_dependencies(self, config: Dict, errors: List[str]):
        """éªŒè¯é…ç½®é¡¹ä¹‹é—´çš„ä¾èµ–å…³ç³»"""
        # é€šçŸ¥é…ç½®ä¾èµ–æ£€æŸ¥
        if self._get_nested_value(config, 'notification.enabled'):
            notification_types = self._get_nested_value(config, 'notification.types', [])

            for ntype in notification_types:
                if ntype == 'feishu':
                    webhook = self._get_nested_value(config, 'notification.feishu.webhook')
                    if not webhook:
                        errors.append("å¯ç”¨é£ä¹¦é€šçŸ¥æ—¶å¿…é¡»é…ç½® notification.feishu.webhook")

                elif ntype == 'email':
                    email_config = self._get_nested_value(config, 'notification.email', {})
                    required_email_fields = ['smtp_server', 'sender', 'password', 'receivers']

                    for field in required_email_fields:
                        if not email_config.get(field):
                            errors.append(f"å¯ç”¨é‚®ä»¶é€šçŸ¥æ—¶å¿…é¡»é…ç½® notification.email.{field}")

        # æ•°æ®åº“é…ç½®ä¾èµ–æ£€æŸ¥
        if self._get_nested_value(config, 'database.enabled'):
            db_config = self._get_nested_value(config, 'database', {})
            required_db_fields = ['host', 'port', 'username', 'password', 'database']

            for field in required_db_fields:
                if not db_config.get(field):
                    errors.append(f"å¯ç”¨æ•°æ®åº“æ—¶å¿…é¡»é…ç½® database.{field}")
```

---

## 5. ç”¨ä¾‹æ‰§è¡Œå¼•æ“

### 5.1 å¹¶å‘æ‰§è¡Œæ¶æ„

````python
class ConcurrentTestExecutor:
    """å¹¶å‘æµ‹è¯•æ‰§è¡Œå™¨"""

    def __init__(self, config_manager: UnifiedConfigManager):
        self.config_manager = config_manager
        self.api_executor_pool = None
        self.web_executor_pool = None
        self.mixed_executor_pool = None

        # æ‰§è¡Œç»Ÿè®¡
        self.execution_stats = ExecutionStats()

        # ç»“æœæ”¶é›†å™¨
        self.result_collector = ResultCollector()

        # åˆå§‹åŒ–çº¿ç¨‹æ± 
        self._initialize_thread_pools()

    def _initialize_thread_pools(self):
        """åˆå§‹åŒ–çº¿ç¨‹æ± """
        concurrent_config = self.config_manager.get_config('execution.concurrent', {})

        if concurrent_config.get('api.enabled', True):
            max_workers = concurrent_config.get('api.max_workers', 3)
            self.api_executor_pool = ThreadPoolExecutor(
                max_workers=max_workers,
                thread_name_prefix='API-Test-'
            )
            logger.info(f"APIæµ‹è¯•çº¿ç¨‹æ± åˆå§‹åŒ–å®Œæˆï¼Œæœ€å¤§å·¥ä½œçº¿ç¨‹æ•°: {max_workers}")

        if concurrent_config.get('web.enabled', True):
            max_workers = concurrent_config.get('web.max_workers', 2)
            self.web_executor_pool = ThreadPoolExecutor(
                max_workers=max_workers,
                thread_name_prefix='Web-Test-'
            )
            logger.info(f"Webæµ‹è¯•çº¿ç¨‹æ± åˆå§‹åŒ–å®Œæˆï¼Œæœ€å¤§å·¥ä½œçº¿ç¨‹æ•°: {max_workers}")

        if concurrent_config.get('mixed.enabled', True):
            max_workers = concurrent_config.get('mixed.max_workers', 4)
            self.mixed_executor_pool = ThreadPoolExecutor(
                max_workers=max_workers,
                thread_name_prefix='Mixed-Test-'
            )
            logger.info(f"æ··åˆæµ‹è¯•çº¿ç¨‹æ± åˆå§‹åŒ–å®Œæˆï¼Œæœ€å¤§å·¥ä½œçº¿ç¨‹æ•°: {max_workers}")

    def execute_test_cases_concurrent(self, test_cases: List[Dict]) -> List[TestResult]:
        """å¹¶å‘æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹"""
        if not test_cases:
            return []

        # æŒ‰æµ‹è¯•ç±»å‹åˆ†ç»„
        api_cases, web_cases, mixed_cases = self._group_test_cases(test_cases)

        # æäº¤ä»»åŠ¡åˆ°å¯¹åº”çº¿ç¨‹æ± 
        futures = []

        # APIæµ‹è¯•ä»»åŠ¡
        if api_cases and self.api_executor_pool:
            api_timeout = self.config_manager.get_config('execution.concurrent.api.timeout', 120)
            for case in api_cases:
                future = self.api_executor_pool.submit(
                    self._execute_single_test_with_timeout, case, api_timeout
                )
                futures.append(future)

        # Webæµ‹è¯•ä»»åŠ¡
        if web_cases and self.web_executor_pool:
            web_timeout = self.config_manager.get_config('execution.concurrent.web.timeout', 300)
            for case in web_cases:
                future = self.web_executor_pool.submit(
                    self._execute_single_test_with_timeout, case, web_timeout
                )
                futures.append(future)

        # æ··åˆæµ‹è¯•ä»»åŠ¡
        if mixed_cases and self.mixed_executor_pool:
            mixed_timeout = self.config_manager.get_config('execution.concurrent.mixed.timeout', 300)
            for case in mixed_cases:
                future = self.mixed_executor_pool.submit(
                    self._execute_single_test_with_timeout, case, mixed_timeout
                )
                futures.append(future)

        # æ”¶é›†ç»“æœ
        results = []
        completed_count = 0
        total_count = len(futures)

        logger.info(f"å¼€å§‹å¹¶å‘æ‰§è¡Œ {total_count} ä¸ªæµ‹è¯•ç”¨ä¾‹")

        for future in as_completed(futures):
            try:
                result = future.result()
                results.append(result)
                completed_count += 1

                # å®æ—¶è¿›åº¦æŠ¥å‘Š
                progress = (completed_count / total_count) * 100
                logger.info(f"æµ‹è¯•è¿›åº¦: {completed_count}/{total_count} ({progress:.1f}%)")

            except Exception as e:
                logger.error(f"æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œå¼‚å¸¸: {e}")
                # åˆ›å»ºå¤±è´¥ç»“æœ
                error_result = TestResult("Unknown")
                error_result.status = TestStatus.FAILED
                error_result.error_message = str(e)
                results.append(error_result)

        logger.info(f"å¹¶å‘æµ‹è¯•æ‰§è¡Œå®Œæˆï¼Œå…±æ‰§è¡Œ {len(results)} ä¸ªç”¨ä¾‹")
        return results

    def _execute_single_test_with_timeout(self, test_case: Dict, timeout: int) -> TestResult:
        """å¸¦è¶…æ—¶çš„å•ä¸ªæµ‹è¯•æ‰§è¡Œ"""
        case_name = test_case.get('case_name', 'Unknown')

        try:
            # åˆ›å»ºæµ‹è¯•æ‰§è¡Œå™¨å®ä¾‹ï¼ˆæ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹ï¼‰
            executor = TestExecutor()

            # è®¾ç½®è¶…æ—¶
            signal.signal(signal.SIGALRM, self._timeout_handler)
            signal.alarm(timeout)

            try:
                result = executor.execute_test_case(test_case)
                signal.alarm(0)  # å–æ¶ˆè¶…æ—¶
                return result

            except TimeoutError:
                logger.error(f"æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œè¶…æ—¶: {case_name}, è¶…æ—¶æ—¶é—´: {timeout}ç§’")
                result = TestResult(case_name)
                result.status = TestStatus.FAILED
                result.error_message = f"æµ‹è¯•æ‰§è¡Œè¶…æ—¶ ({timeout}ç§’)"
                return result

        except Exception as e:
            logger.error(f"æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œå¼‚å¸¸: {case_name}, é”™è¯¯: {e}")
            result = TestResult(case_name)
            result.status = TestStatus.FAILED
            result.error_message = str(e)
            return result
        finally:
            signal.alarm(0)  # ç¡®ä¿å–æ¶ˆè¶…æ—¶

    def _timeout_handler(self, signum, frame):
        """è¶…æ—¶å¤„ç†å™¨"""
        raise TimeoutError("æµ‹è¯•æ‰§è¡Œè¶…æ—¶")

    def _group_test_cases(self, test_cases: List[Dict]) -> Tuple[List[Dict], List[Dict], List[Dict]]:
        """æŒ‰æµ‹è¯•ç±»å‹åˆ†ç»„æµ‹è¯•ç”¨ä¾‹"""
        api_cases = []
        web_cases = []
        mixed_cases = []

        for case in test_cases:
            test_type = self._determine_test_type(case)

            if test_type == 'api':
                api_cases.append(case)
            elif test_type == 'web':
                web_cases.append(case)
            else:
                mixed_cases.append(case)

        return api_cases, web_cases, mixed_cases

    def _determine_test_type(self, test_case: Dict) -> str:
        """ç¡®å®šæµ‹è¯•ç”¨ä¾‹ç±»å‹"""
        if 'request' in test_case:
            return 'api'
        elif 'steps' in test_case:
            steps = test_case['steps']
            web_actions = ['navigate', 'click', 'input', 'wait', 'scroll', 'screenshot']
            api_actions = ['send_request', 'get', 'post', 'put', 'delete']

            has_web = any(step.get('action') in web_actions for step in steps)
            has_api = any(step.get('action') in api_actions for step in steps)

            if has_web and has_api:
                return 'mixed'
            elif has_web:
                return 'web'
            elif has_api:
                return 'api'

        return 'mixed'  # é»˜è®¤ä¸ºæ··åˆç±»å‹

---

## 6. å…³é”®å­—é©±åŠ¨å®ç°

### 6.1 å…³é”®å­—å¼•æ“æ¶æ„

```python
class KeywordEngine:
    """å…³é”®å­—é©±åŠ¨å¼•æ“ - æ¡†æ¶çš„æ ¸å¿ƒæ‰§è¡Œå¼•æ“"""

    def __init__(self):
        self.keyword_registry = {}
        self.execution_context = ExecutionContext()
        self.variable_manager = VariableManager()

        # æ³¨å†Œå†…ç½®å…³é”®å­—
        self._register_builtin_keywords()

        # åŠ è½½è‡ªå®šä¹‰å…³é”®å­—
        self._load_custom_keywords()

    def _register_builtin_keywords(self):
        """æ³¨å†Œå†…ç½®å…³é”®å­—"""
        # APIå…³é”®å­—
        api_keywords = APIKeywords()
        self.register_keyword_class(api_keywords)

        # Webå…³é”®å­—
        web_keywords = WebKeywords()
        self.register_keyword_class(web_keywords)

        # æ•°æ®åº“å…³é”®å­—
        db_keywords = DatabaseKeywords()
        self.register_keyword_class(db_keywords)

        # å·¥å…·å…³é”®å­—
        util_keywords = UtilityKeywords()
        self.register_keyword_class(util_keywords)

    def register_keyword_class(self, keyword_class):
        """æ³¨å†Œå…³é”®å­—ç±»"""
        class_name = keyword_class.__class__.__name__

        # è·å–æ‰€æœ‰å…¬å…±æ–¹æ³•ä½œä¸ºå…³é”®å­—
        for method_name in dir(keyword_class):
            if not method_name.startswith('_') and callable(getattr(keyword_class, method_name)):
                keyword_name = method_name
                self.keyword_registry[keyword_name] = getattr(keyword_class, method_name)
                logger.debug(f"æ³¨å†Œå…³é”®å­—: {keyword_name} (æ¥è‡ª {class_name})")

    def execute_keyword(self, keyword_name: str, params: Dict[str, Any]) -> Any:
        """æ‰§è¡Œå…³é”®å­—"""
        if keyword_name not in self.keyword_registry:
            raise KeywordNotFoundError(f"å…³é”®å­— '{keyword_name}' æœªæ‰¾åˆ°")

        keyword_func = self.keyword_registry[keyword_name]

        try:
            # å¤„ç†å‚æ•°ä¸­çš„å˜é‡æ›¿æ¢
            processed_params = self.variable_manager.process_variables(params)

            # è®°å½•å…³é”®å­—æ‰§è¡Œ
            logger.info(f"æ‰§è¡Œå…³é”®å­—: {keyword_name}, å‚æ•°: {processed_params}")

            # æ‰§è¡Œå…³é”®å­—
            result = keyword_func(**processed_params)

            # ä¿å­˜æ‰§è¡Œç»“æœåˆ°ä¸Šä¸‹æ–‡
            self.execution_context.set_last_result(result)

            return result

        except Exception as e:
            logger.error(f"å…³é”®å­—æ‰§è¡Œå¤±è´¥: {keyword_name}, é”™è¯¯: {e}")
            raise KeywordExecutionError(f"å…³é”®å­— '{keyword_name}' æ‰§è¡Œå¤±è´¥: {e}")

class APIKeywords:
    """APIæµ‹è¯•å…³é”®å­—é›†åˆ"""

    def __init__(self):
        self.client = APIClient()
        self.assertion_helper = AssertionHelper()
        self.data_extractor = DataExtractor()

    def send_request(self, method: str, url: str, **kwargs) -> requests.Response:
        """å‘é€HTTPè¯·æ±‚"""
        return self.client.send_request(method, url, **kwargs)

    def get(self, url: str, **kwargs) -> requests.Response:
        """å‘é€GETè¯·æ±‚"""
        return self.send_request('GET', url, **kwargs)

    def post(self, url: str, **kwargs) -> requests.Response:
        """å‘é€POSTè¯·æ±‚"""
        return self.send_request('POST', url, **kwargs)

    def put(self, url: str, **kwargs) -> requests.Response:
        """å‘é€PUTè¯·æ±‚"""
        return self.send_request('PUT', url, **kwargs)

    def delete(self, url: str, **kwargs) -> requests.Response:
        """å‘é€DELETEè¯·æ±‚"""
        return self.send_request('DELETE', url, **kwargs)

    def assert_status_code(self, response: requests.Response, expected: int):
        """æ–­è¨€çŠ¶æ€ç """
        self.assertion_helper.assert_status_code(response, expected)

    def assert_json_path(self, response: requests.Response, path: str, expected: Any, operator: str = 'equals'):
        """æ–­è¨€JSONè·¯å¾„å€¼"""
        self.assertion_helper.assert_json_path(response, path, expected, operator)

    def extract_json_path(self, response: requests.Response, path: str, variable_name: str):
        """ä»å“åº”ä¸­æå–JSONè·¯å¾„å€¼"""
        value = self.data_extractor.extract_json_path(response.json(), path)
        VariableManager().set_variable(variable_name, value)
        return value

    def extract_header(self, response: requests.Response, header_name: str, variable_name: str):
        """ä»å“åº”å¤´ä¸­æå–å€¼"""
        value = response.headers.get(header_name)
        VariableManager().set_variable(variable_name, value)
        return value

class WebKeywords:
    """Webæµ‹è¯•å…³é”®å­—é›†åˆ"""

    def __init__(self):
        self.browser_manager = BrowserManager()
        self.page = None

    def open_browser(self, browser_type: str = 'chromium', headless: bool = False):
        """æ‰“å¼€æµè§ˆå™¨"""
        self.page = self.browser_manager.create_page(browser_type, headless)
        return self.page

    def navigate(self, url: str):
        """å¯¼èˆªåˆ°æŒ‡å®šURL"""
        if not self.page:
            self.open_browser()

        self.page.goto(url)
        logger.info(f"å¯¼èˆªåˆ°: {url}")

    def click(self, locator: str, timeout: int = 30000):
        """ç‚¹å‡»å…ƒç´ """
        self.page.click(locator, timeout=timeout)
        logger.info(f"ç‚¹å‡»å…ƒç´ : {locator}")

    def input(self, locator: str, value: str, timeout: int = 30000):
        """è¾“å…¥æ–‡æœ¬"""
        self.page.fill(locator, value, timeout=timeout)
        logger.info(f"è¾“å…¥æ–‡æœ¬åˆ° {locator}: {value}")

    def wait_for_element(self, locator: str, timeout: int = 30000):
        """ç­‰å¾…å…ƒç´ å‡ºç°"""
        self.page.wait_for_selector(locator, timeout=timeout)
        logger.info(f"ç­‰å¾…å…ƒç´ : {locator}")

    def wait_for_url(self, url_pattern: str, timeout: int = 30000):
        """ç­‰å¾…URLåŒ¹é…"""
        self.page.wait_for_url(url_pattern, timeout=timeout)
        logger.info(f"ç­‰å¾…URL: {url_pattern}")

    def screenshot(self, file_path: str = None):
        """æˆªå›¾"""
        if not file_path:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_path = f"screenshots/screenshot_{timestamp}.png"

        self.page.screenshot(path=file_path)
        logger.info(f"æˆªå›¾ä¿å­˜åˆ°: {file_path}")
        return file_path

    def get_text(self, locator: str, variable_name: str = None):
        """è·å–å…ƒç´ æ–‡æœ¬"""
        text = self.page.text_content(locator)

        if variable_name:
            VariableManager().set_variable(variable_name, text)

        logger.info(f"è·å–æ–‡æœ¬ {locator}: {text}")
        return text

    def assert_element_visible(self, locator: str):
        """æ–­è¨€å…ƒç´ å¯è§"""
        is_visible = self.page.is_visible(locator)
        if not is_visible:
            raise AssertionError(f"å…ƒç´ ä¸å¯è§: {locator}")
        logger.info(f"æ–­è¨€å…ƒç´ å¯è§: {locator}")

    def assert_text_contains(self, locator: str, expected_text: str):
        """æ–­è¨€å…ƒç´ æ–‡æœ¬åŒ…å«æŒ‡å®šå†…å®¹"""
        actual_text = self.page.text_content(locator)
        if expected_text not in actual_text:
            raise AssertionError(f"æ–‡æœ¬æ–­è¨€å¤±è´¥: æœŸæœ›åŒ…å« '{expected_text}', å®é™… '{actual_text}'")
        logger.info(f"æ–­è¨€æ–‡æœ¬åŒ…å«: {locator} åŒ…å« '{expected_text}'")

    def close_browser(self):
        """å…³é—­æµè§ˆå™¨"""
        if self.page:
            self.browser_manager.close_page(self.page)
            self.page = None
        logger.info("æµè§ˆå™¨å·²å…³é—­")

class VariableManager:
    """å˜é‡ç®¡ç†å™¨ - ç®¡ç†æµ‹è¯•æ‰§è¡Œè¿‡ç¨‹ä¸­çš„å˜é‡"""

    _instance = None
    _variables = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def set_variable(self, name: str, value: Any):
        """è®¾ç½®å˜é‡"""
        self._variables[name] = value
        logger.debug(f"è®¾ç½®å˜é‡: {name} = {value}")

    def get_variable(self, name: str, default: Any = None) -> Any:
        """è·å–å˜é‡"""
        return self._variables.get(name, default)

    def process_variables(self, data: Any) -> Any:
        """å¤„ç†æ•°æ®ä¸­çš„å˜é‡å¼•ç”¨"""
        if isinstance(data, str):
            return self._replace_variables_in_string(data)
        elif isinstance(data, dict):
            return {k: self.process_variables(v) for k, v in data.items()}
        elif isinstance(data, list):
            return [self.process_variables(item) for item in data]
        else:
            return data

    def _replace_variables_in_string(self, text: str) -> str:
        """æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„å˜é‡å¼•ç”¨"""
        # æ”¯æŒ ${variable_name} æ ¼å¼çš„å˜é‡å¼•ç”¨
        pattern = r'\$\{([^}]+)\}'

        def replace_var(match):
            var_name = match.group(1)
            var_value = self.get_variable(var_name)

            if var_value is None:
                logger.warning(f"å˜é‡ '{var_name}' æœªå®šä¹‰")
                return match.group(0)  # è¿”å›åŸå§‹å­—ç¬¦ä¸²

            return str(var_value)

        return re.sub(pattern, replace_var, text)

    def clear_variables(self):
        """æ¸…ç©ºæ‰€æœ‰å˜é‡"""
        self._variables.clear()
        logger.debug("æ‰€æœ‰å˜é‡å·²æ¸…ç©º")

    def get_all_variables(self) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰å˜é‡"""
        return self._variables.copy()
````

### 6.2 è‡ªå®šä¹‰å…³é”®å­—æ‰©å±•æœºåˆ¶

```python
class CustomKeywordLoader:
    """è‡ªå®šä¹‰å…³é”®å­—åŠ è½½å™¨"""

    def __init__(self, keyword_engine: KeywordEngine):
        self.keyword_engine = keyword_engine
        self.custom_keywords_dir = Path("plugins/keywords")

    def load_custom_keywords(self):
        """åŠ è½½è‡ªå®šä¹‰å…³é”®å­—"""
        if not self.custom_keywords_dir.exists():
            logger.info("è‡ªå®šä¹‰å…³é”®å­—ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡åŠ è½½")
            return

        # æ‰«æPythonæ–‡ä»¶
        for py_file in self.custom_keywords_dir.glob("*.py"):
            if py_file.name.startswith("__"):
                continue

            try:
                self._load_keyword_module(py_file)
            except Exception as e:
                logger.error(f"åŠ è½½è‡ªå®šä¹‰å…³é”®å­—æ–‡ä»¶å¤±è´¥: {py_file}, é”™è¯¯: {e}")

    def _load_keyword_module(self, py_file: Path):
        """åŠ è½½å…³é”®å­—æ¨¡å—"""
        module_name = py_file.stem
        spec = importlib.util.spec_from_file_location(module_name, py_file)
        module = importlib.util.module_from_spec(spec)

        # æ‰§è¡Œæ¨¡å—
        spec.loader.exec_module(module)

        # æŸ¥æ‰¾å…³é”®å­—ç±»
        for attr_name in dir(module):
            attr = getattr(module, attr_name)

            # æ£€æŸ¥æ˜¯å¦æ˜¯å…³é”®å­—ç±»
            if (isinstance(attr, type) and
                hasattr(attr, '__keywords__') and
                attr.__keywords__):

                # å®ä¾‹åŒ–å¹¶æ³¨å†Œå…³é”®å­—ç±»
                keyword_instance = attr()
                self.keyword_engine.register_keyword_class(keyword_instance)
                logger.info(f"åŠ è½½è‡ªå®šä¹‰å…³é”®å­—ç±»: {attr_name} (æ¥è‡ª {py_file})")

# è‡ªå®šä¹‰å…³é”®å­—ç¤ºä¾‹
class BusinessKeywords:
    """ä¸šåŠ¡å…³é”®å­—ç¤ºä¾‹"""
    __keywords__ = True  # æ ‡è®°ä¸ºå…³é”®å­—ç±»

    def __init__(self):
        self.api_keywords = APIKeywords()
        self.variable_manager = VariableManager()

    def user_login(self, username: str, password: str) -> Dict[str, Any]:
        """ç”¨æˆ·ç™»å½•ä¸šåŠ¡å…³é”®å­—"""
        login_data = {
            "username": username,
            "password": password
        }

        # å‘é€ç™»å½•è¯·æ±‚
        response = self.api_keywords.post("/api/login", json=login_data)

        # éªŒè¯ç™»å½•æˆåŠŸ
        self.api_keywords.assert_status_code(response, 200)
        self.api_keywords.assert_json_path(response, "$.code", 0)

        # æå–token
        token = self.api_keywords.extract_json_path(response, "$.data.token", "auth_token")

        logger.info(f"ç”¨æˆ· {username} ç™»å½•æˆåŠŸï¼Œtoken: {token}")

        return {
            "username": username,
            "token": token,
            "login_time": datetime.now().isoformat()
        }

    def create_test_data(self, data_type: str, count: int = 1) -> List[Dict]:
        """åˆ›å»ºæµ‹è¯•æ•°æ®ä¸šåŠ¡å…³é”®å­—"""
        faker_helper = FakerHelper()
        test_data = []

        for i in range(count):
            if data_type == "user":
                data = {
                    "username": faker_helper.generate("user_name"),
                    "email": faker_helper.generate("email"),
                    "phone": faker_helper.generate("phone_number"),
                    "address": faker_helper.generate("address")
                }
            elif data_type == "product":
                data = {
                    "name": faker_helper.generate("catch_phrase"),
                    "price": faker_helper.generate("random_number", digits=3),
                    "description": faker_helper.generate("text", max_nb_chars=200)
                }
            else:
                raise ValueError(f"ä¸æ”¯æŒçš„æ•°æ®ç±»å‹: {data_type}")

            test_data.append(data)

        # ä¿å­˜åˆ°å˜é‡
        self.variable_manager.set_variable(f"test_{data_type}_data", test_data)

        logger.info(f"åˆ›å»º {count} æ¡ {data_type} æµ‹è¯•æ•°æ®")
        return test_data
```

---

## 7. æŠ¥å‘Šä¸é€šçŸ¥ç³»ç»Ÿ

### 7.1 å¤šæ ¼å¼æŠ¥å‘Šç”Ÿæˆ

```python
class ReportGenerator:
    """æŠ¥å‘Šç”Ÿæˆå™¨ - æ”¯æŒå¤šç§æŠ¥å‘Šæ ¼å¼"""

    def __init__(self, config_manager: UnifiedConfigManager):
        self.config_manager = config_manager
        self.report_strategies = {
            'allure': AllureReportStrategy(),
            'pytest-html': PytestHtmlReportStrategy(),
            'json': JsonReportStrategy(),
            'excel': ExcelReportStrategy()
        }

    def generate_reports(self, report_types: List[str], test_results: List[TestResult]):
        """ç”ŸæˆæŒ‡å®šç±»å‹çš„æŠ¥å‘Š"""
        if not report_types:
            report_types = ['pytest-html']  # é»˜è®¤æŠ¥å‘Šç±»å‹

        generated_reports = []

        for report_type in report_types:
            if report_type in self.report_strategies:
                try:
                    strategy = self.report_strategies[report_type]
                    report_path = strategy.generate(test_results, self.config_manager)
                    generated_reports.append({
                        'type': report_type,
                        'path': report_path,
                        'url': self._get_report_url(report_path)
                    })
                    logger.info(f"{report_type} æŠ¥å‘Šç”ŸæˆæˆåŠŸ: {report_path}")
                except Exception as e:
                    logger.error(f"{report_type} æŠ¥å‘Šç”Ÿæˆå¤±è´¥: {e}")
            else:
                logger.warning(f"ä¸æ”¯æŒçš„æŠ¥å‘Šç±»å‹: {report_type}")

        return generated_reports

    def _get_report_url(self, report_path: str) -> str:
        """è·å–æŠ¥å‘Šè®¿é—®URL"""
        # å¦‚æœé…ç½®äº†æŠ¥å‘ŠæœåŠ¡å™¨ï¼Œè¿”å›å®Œæ•´URL
        report_server = self.config_manager.get_config('report.server_url')
        if report_server:
            relative_path = Path(report_path).relative_to(Path.cwd())
            return f"{report_server.rstrip('/')}/{relative_path}"

        # å¦åˆ™è¿”å›æœ¬åœ°æ–‡ä»¶è·¯å¾„
        return f"file://{Path(report_path).absolute()}"

class AllureReportStrategy:
    """AllureæŠ¥å‘Šç”Ÿæˆç­–ç•¥"""

    def generate(self, test_results: List[TestResult], config_manager: UnifiedConfigManager) -> str:
        """ç”ŸæˆAllureæŠ¥å‘Š"""
        allure_results_dir = Path("reports/allure-results")
        allure_report_dir = Path("reports/allure-report")

        # æ¸…ç†æ—§çš„ç»“æœ
        if allure_results_dir.exists():
            shutil.rmtree(allure_results_dir)
        allure_results_dir.mkdir(parents=True, exist_ok=True)

        # ç”ŸæˆAllureç»“æœæ–‡ä»¶
        for result in test_results:
            self._generate_allure_result_file(result, allure_results_dir)

        # ç”ŸæˆAllureæŠ¥å‘Š
        try:
            subprocess.run([
                'allure', 'generate', str(allure_results_dir),
                '-o', str(allure_report_dir), '--clean'
            ], check=True, capture_output=True, text=True)

            return str(allure_report_dir / "index.html")

        except subprocess.CalledProcessError as e:
            logger.error(f"AllureæŠ¥å‘Šç”Ÿæˆå¤±è´¥: {e}")
            raise
        except FileNotFoundError:
            logger.error("Allureå‘½ä»¤æœªæ‰¾åˆ°ï¼Œè¯·ç¡®ä¿å·²å®‰è£…Allure")
            raise

    def _generate_allure_result_file(self, result: TestResult, results_dir: Path):
        """ç”Ÿæˆå•ä¸ªæµ‹è¯•ç»“æœçš„Allureæ–‡ä»¶"""
        test_result = {
            "uuid": str(uuid.uuid4()),
            "name": result.case_name,
            "fullName": result.case_name,
            "status": self._map_status(result.status),
            "start": int(result.start_time.timestamp() * 1000) if result.start_time else None,
            "stop": int(result.end_time.timestamp() * 1000) if result.end_time else None,
            "labels": [
                {"name": "suite", "value": result.suite_name or "Default"},
                {"name": "testClass", "value": result.test_class or "TestCase"},
                {"name": "testMethod", "value": result.case_name}
            ],
            "parameters": [],
            "attachments": []
        }

        # æ·»åŠ é”™è¯¯ä¿¡æ¯
        if result.status == TestStatus.FAILED and result.error_message:
            test_result["statusDetails"] = {
                "message": result.error_message,
                "trace": result.exception_traceback if hasattr(result, 'exception_traceback') else ""
            }

        # æ·»åŠ æ­¥éª¤ä¿¡æ¯
        if hasattr(result, 'step_results') and result.step_results:
            test_result["steps"] = []
            for step in result.step_results:
                step_data = {
                    "name": step['name'],
                    "status": self._map_status(step['status']),
                    "start": int(time.time() * 1000),
                    "stop": int(time.time() * 1000)
                }
                test_result["steps"].append(step_data)

        # æ·»åŠ é™„ä»¶ï¼ˆæˆªå›¾ç­‰ï¼‰
        if hasattr(result, 'attachments') and result.attachments:
            for attachment in result.attachments:
                attachment_data = {
                    "name": attachment['name'],
                    "source": attachment['path'],
                    "type": attachment['type']
                }
                test_result["attachments"].append(attachment_data)

        # å†™å…¥æ–‡ä»¶
        result_file = results_dir / f"{test_result['uuid']}-result.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(test_result, f, ensure_ascii=False, indent=2)

    def _map_status(self, status) -> str:
        """æ˜ å°„æµ‹è¯•çŠ¶æ€åˆ°AllureçŠ¶æ€"""
        status_mapping = {
            TestStatus.PASSED: "passed",
            TestStatus.FAILED: "failed",
            TestStatus.SKIPPED: "skipped",
            "passed": "passed",
            "failed": "failed",
            "skipped": "skipped"
        }
        return status_mapping.get(status, "unknown")

class PytestHtmlReportStrategy:
    """Pytest HTMLæŠ¥å‘Šç”Ÿæˆç­–ç•¥"""

    def generate(self, test_results: List[TestResult], config_manager: UnifiedConfigManager) -> str:
        """ç”ŸæˆPytest HTMLæŠ¥å‘Š"""
        report_dir = Path("reports/html")
        report_dir.mkdir(parents=True, exist_ok=True)

        report_file = report_dir / "report.html"

        # ç”ŸæˆHTMLæŠ¥å‘Šå†…å®¹
        html_content = self._generate_html_content(test_results)

        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(html_content)

        return str(report_file)

    def _generate_html_content(self, test_results: List[TestResult]) -> str:
        """ç”ŸæˆHTMLæŠ¥å‘Šå†…å®¹"""
        # ç»Ÿè®¡ä¿¡æ¯
        total_count = len(test_results)
        passed_count = sum(1 for r in test_results if r.status == TestStatus.PASSED)
        failed_count = sum(1 for r in test_results if r.status == TestStatus.FAILED)
        skipped_count = sum(1 for r in test_results if r.status == TestStatus.SKIPPED)

        pass_rate = (passed_count / total_count * 100) if total_count > 0 else 0

        # ç”ŸæˆHTML
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>è‡ªåŠ¨åŒ–æµ‹è¯•æŠ¥å‘Š</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background: #f5f5f5; padding: 20px; border-radius: 5px; }
                .summary { display: flex; gap: 20px; margin: 20px 0; }
                .stat-card { background: white; border: 1px solid #ddd; padding: 15px; border-radius: 5px; text-align: center; }
                .passed { border-left: 4px solid #28a745; }
                .failed { border-left: 4px solid #dc3545; }
                .skipped { border-left: 4px solid #ffc107; }
                .total { border-left: 4px solid #007bff; }
                table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #f2f2f2; }
                .status-passed { color: #28a745; font-weight: bold; }
                .status-failed { color: #dc3545; font-weight: bold; }
                .status-skipped { color: #ffc107; font-weight: bold; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>è‡ªåŠ¨åŒ–æµ‹è¯•æŠ¥å‘Š</h1>
                <p>ç”Ÿæˆæ—¶é—´: {timestamp}</p>
                <p>é€šè¿‡ç‡: {pass_rate:.1f}%</p>
            </div>

            <div class="summary">
                <div class="stat-card total">
                    <h3>{total_count}</h3>
                    <p>æ€»è®¡</p>
                </div>
                <div class="stat-card passed">
                    <h3>{passed_count}</h3>
                    <p>é€šè¿‡</p>
                </div>
                <div class="stat-card failed">
                    <h3>{failed_count}</h3>
                    <p>å¤±è´¥</p>
                </div>
                <div class="stat-card skipped">
                    <h3>{skipped_count}</h3>
                    <p>è·³è¿‡</p>
                </div>
            </div>

            <table>
                <thead>
                    <tr>
                        <th>ç”¨ä¾‹åç§°</th>
                        <th>çŠ¶æ€</th>
                        <th>æ‰§è¡Œæ—¶é—´</th>
                        <th>é”™è¯¯ä¿¡æ¯</th>
                    </tr>
                </thead>
                <tbody>
                    {test_rows}
                </tbody>
            </table>
        </body>
        </html>
        """

        # ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹è¡Œ
        test_rows = []
        for result in test_results:
            status_class = f"status-{result.status.value.lower()}" if hasattr(result.status, 'value') else f"status-{str(result.status).lower()}"
            duration = ""
            if result.start_time and result.end_time:
                duration = f"{(result.end_time - result.start_time).total_seconds():.2f}s"

            error_msg = result.error_message or ""
            if len(error_msg) > 100:
                error_msg = error_msg[:100] + "..."

            row = f"""
                <tr>
                    <td>{result.case_name}</td>
                    <td class="{status_class}">{result.status}</td>
                    <td>{duration}</td>
                    <td>{error_msg}</td>
                </tr>
            """
            test_rows.append(row)

        return html_template.format(
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            pass_rate=pass_rate,
            total_count=total_count,
            passed_count=passed_count,
            failed_count=failed_count,
            skipped_count=skipped_count,
            test_rows="".join(test_rows)
        )
```

### 7.2 æ™ºèƒ½é€šçŸ¥ç³»ç»Ÿ

````python
class NotificationSender:
    """æ™ºèƒ½é€šçŸ¥å‘é€å™¨"""

    def __init__(self, config_manager: UnifiedConfigManager):
        self.config_manager = config_manager
        self.notification_strategies = {
            'feishu': FeishuNotificationStrategy(),
            'email': EmailNotificationStrategy(),
            'wechat': WechatNotificationStrategy(),
            'dingtalk': DingtalkNotificationStrategy()
        }

    def send_notifications(self, test_results: List[TestResult], report_info: Dict[str, Any]):
        """å‘é€æµ‹è¯•ç»“æœé€šçŸ¥"""
        notification_config = self.config_manager.get_config('notification', {})

        if not notification_config.get('enabled', False):
            logger.info("é€šçŸ¥åŠŸèƒ½æœªå¯ç”¨")
            return

        notification_types = notification_config.get('types', [])
        if not notification_types:
            logger.info("æœªé…ç½®é€šçŸ¥ç±»å‹")
            return

        # ç”Ÿæˆé€šçŸ¥å†…å®¹
        notification_content = self._generate_notification_content(test_results, report_info)

        # å‘é€é€šçŸ¥
        for ntype in notification_types:
            if ntype in self.notification_strategies:
                try:
                    strategy = self.notification_strategies[ntype]
                    strategy.send(notification_content, notification_config.get(ntype, {}))
                    logger.info(f"{ntype} é€šçŸ¥å‘é€æˆåŠŸ")
                except Exception as e:
                    logger.error(f"{ntype} é€šçŸ¥å‘é€å¤±è´¥: {e}")
            else:
                logger.warning(f"ä¸æ”¯æŒçš„é€šçŸ¥ç±»å‹: {ntype}")

    def _generate_notification_content(self, test_results: List[TestResult], report_info: Dict) -> Dict[str, Any]:
        """ç”Ÿæˆé€šçŸ¥å†…å®¹"""
        total_count = len(test_results)
        passed_count = sum(1 for r in test_results if r.status == TestStatus.PASSED)
        failed_count = sum(1 for r in test_results if r.status == TestStatus.FAILED)
        skipped_count = sum(1 for r in test_results if r.status == TestStatus.SKIPPED)

        pass_rate = (passed_count / total_count * 100) if total_count > 0 else 0

        # è·å–å¤±è´¥ç”¨ä¾‹ä¿¡æ¯
        failed_cases = [r for r in test_results if r.status == TestStatus.FAILED]
        failed_case_names = [case.case_name for case in failed_cases[:5]]  # æœ€å¤šæ˜¾ç¤º5ä¸ªå¤±è´¥ç”¨ä¾‹

        return {
            'title': 'è‡ªåŠ¨åŒ–æµ‹è¯•æ‰§è¡Œå®Œæˆ',
            'summary': f'æ€»è®¡ {total_count} ä¸ªç”¨ä¾‹ï¼Œé€šè¿‡ {passed_count} ä¸ªï¼Œå¤±è´¥ {failed_count} ä¸ªï¼Œè·³è¿‡ {skipped_count} ä¸ª',
            'pass_rate': pass_rate,
            'total_count': total_count,
            'passed_count': passed_count,
            'failed_count': failed_count,
            'skipped_count': skipped_count,
            'failed_cases': failed_case_names,
            'report_url': report_info.get('url', ''),
            'execution_time': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'status': 'success' if failed_count == 0 else 'failed'
        }

class FeishuNotificationStrategy:
    """é£ä¹¦é€šçŸ¥ç­–ç•¥"""

    def send(self, content: Dict[str, Any], config: Dict[str, Any]):
        """å‘é€é£ä¹¦é€šçŸ¥"""
        webhook_url = config.get('webhook')
        if not webhook_url:
            raise ValueError("é£ä¹¦é€šçŸ¥ç¼ºå°‘webhooké…ç½®")

        # æ„å»ºé£ä¹¦æ¶ˆæ¯å¡ç‰‡
        card_content = self._build_feishu_card(content)

        payload = {
            "msg_type": "interactive",
            "card": card_content
        }

        response = requests.post(webhook_url, json=payload)
        response.raise_for_status()

        result = response.json()
        if result.get('code') != 0:
            raise Exception(f"é£ä¹¦é€šçŸ¥å‘é€å¤±è´¥: {result.get('msg', 'Unknown error')}")

    def _build_feishu_card(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """æ„å»ºé£ä¹¦æ¶ˆæ¯å¡ç‰‡"""
        status_color = "green" if content['status'] == 'success' else "red"
        status_text = "âœ… æµ‹è¯•é€šè¿‡" if content['status'] == 'success' else "âŒ æµ‹è¯•å¤±è´¥"

        card = {
            "config": {
                "wide_screen_mode": True
            },
            "header": {
                "title": {
                    "content": content['title'],
                    "tag": "plain_text"
                },
                "template": status_color
            },
            "elements": [
                {
                    "tag": "div",
                    "text": {
                        "content": f"**{status_text}**\n{content['summary']}",
                        "tag": "lark_md"
                    }
                },
                {
                    "tag": "hr"
                },
                {
                    "tag": "div",
                    "fields": [
                        {
                            "is_short": True,
                            "text": {
                                "content": f"**é€šè¿‡ç‡**\n{content['pass_rate']:.1f}%",
                                "tag": "lark_md"
                            }
                        },
                        {
                            "is_short": True,
                            "text": {
                                "content": f"**æ‰§è¡Œæ—¶é—´**\n{content['execution_time']}",
                                "tag": "lark_md"
                            }
                        }
                    ]
                }
            ]
        }

        # æ·»åŠ å¤±è´¥ç”¨ä¾‹ä¿¡æ¯
        if content['failed_cases']:
            failed_text = "**å¤±è´¥ç”¨ä¾‹:**\n" + "\n".join([f"â€¢ {case}" for case in content['failed_cases']])
            if content['failed_count'] > len(content['failed_cases']):
                failed_text += f"\n... è¿˜æœ‰ {content['failed_count'] - len(content['failed_cases'])} ä¸ªå¤±è´¥ç”¨ä¾‹"

            card["elements"].append({
                "tag": "div",
                "text": {
                    "content": failed_text,
                    "tag": "lark_md"
                }
            })

        # æ·»åŠ æŠ¥å‘Šé“¾æ¥
        if content['report_url']:
            card["elements"].extend([
                {
                    "tag": "hr"
                },
                {
                    "tag": "action",
                    "actions": [
                        {
                            "tag": "button",
                            "text": {
                                "content": "æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Š",
                                "tag": "plain_text"
                            },
                            "url": content['report_url'],
                            "type": "primary"
                        }
                    ]
                }
            ])

        return card

---

## 8. æ‰©å±•å¼€å‘æŒ‡å—

### 8.1 æ’ä»¶ç³»ç»Ÿæ¶æ„

```python
class PluginSystem:
    """æ’ä»¶ç³»ç»Ÿ - æ”¯æŒæ¡†æ¶åŠŸèƒ½æ‰©å±•"""

    def __init__(self):
        self.plugins = {}
        self.hooks = {}
        self.plugin_dir = Path("plugins")

        # åˆå§‹åŒ–æ’ä»¶é’©å­
        self._initialize_hooks()

    def _initialize_hooks(self):
        """åˆå§‹åŒ–æ’ä»¶é’©å­ç‚¹"""
        self.hooks = {
            'before_test_execution': [],
            'after_test_execution': [],
            'before_case_execution': [],
            'after_case_execution': [],
            'on_test_failure': [],
            'on_test_success': [],
            'before_report_generation': [],
            'after_report_generation': [],
            'custom_assertion': [],
            'custom_data_extraction': []
        }

    def register_plugin(self, plugin_name: str, plugin_instance):
        """æ³¨å†Œæ’ä»¶"""
        self.plugins[plugin_name] = plugin_instance

        # æ³¨å†Œæ’ä»¶çš„é’©å­æ–¹æ³•
        for hook_name in self.hooks.keys():
            if hasattr(plugin_instance, hook_name):
                self.hooks[hook_name].append(getattr(plugin_instance, hook_name))
                logger.info(f"æ’ä»¶ {plugin_name} æ³¨å†Œé’©å­: {hook_name}")

        logger.info(f"æ’ä»¶æ³¨å†ŒæˆåŠŸ: {plugin_name}")

    def execute_hook(self, hook_name: str, *args, **kwargs):
        """æ‰§è¡Œé’©å­"""
        if hook_name not in self.hooks:
            logger.warning(f"æœªçŸ¥çš„é’©å­: {hook_name}")
            return

        results = []
        for hook_func in self.hooks[hook_name]:
            try:
                result = hook_func(*args, **kwargs)
                results.append(result)
            except Exception as e:
                logger.error(f"é’©å­æ‰§è¡Œå¤±è´¥: {hook_name}, é”™è¯¯: {e}")

        return results

    def load_plugins(self):
        """åŠ è½½æ‰€æœ‰æ’ä»¶"""
        if not self.plugin_dir.exists():
            logger.info("æ’ä»¶ç›®å½•ä¸å­˜åœ¨ï¼Œè·³è¿‡æ’ä»¶åŠ è½½")
            return

        # æ‰«ææ’ä»¶ç›®å½•
        for plugin_path in self.plugin_dir.iterdir():
            if plugin_path.is_dir() and not plugin_path.name.startswith('__'):
                self._load_plugin_from_directory(plugin_path)

    def _load_plugin_from_directory(self, plugin_path: Path):
        """ä»ç›®å½•åŠ è½½æ’ä»¶"""
        plugin_file = plugin_path / "plugin.py"
        if not plugin_file.exists():
            logger.warning(f"æ’ä»¶ç›®å½•ç¼ºå°‘ plugin.py æ–‡ä»¶: {plugin_path}")
            return

        try:
            # åŠ¨æ€å¯¼å…¥æ’ä»¶æ¨¡å—
            spec = importlib.util.spec_from_file_location(
                f"plugin_{plugin_path.name}", plugin_file
            )
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            # æŸ¥æ‰¾æ’ä»¶ç±»
            plugin_class = getattr(module, 'Plugin', None)
            if plugin_class:
                plugin_instance = plugin_class()
                self.register_plugin(plugin_path.name, plugin_instance)
            else:
                logger.warning(f"æ’ä»¶æ–‡ä»¶ç¼ºå°‘ Plugin ç±»: {plugin_file}")

        except Exception as e:
            logger.error(f"æ’ä»¶åŠ è½½å¤±è´¥: {plugin_path}, é”™è¯¯: {e}")

# æ’ä»¶åŸºç±»
class PluginBase:
    """æ’ä»¶åŸºç±»"""

    def __init__(self):
        self.name = self.__class__.__name__
        self.version = "1.0.0"
        self.description = ""

    def before_test_execution(self, test_suite):
        """æµ‹è¯•æ‰§è¡Œå‰é’©å­"""
        pass

    def after_test_execution(self, test_suite, results):
        """æµ‹è¯•æ‰§è¡Œåé’©å­"""
        pass

    def before_case_execution(self, test_case):
        """ç”¨ä¾‹æ‰§è¡Œå‰é’©å­"""
        pass

    def after_case_execution(self, test_case, result):
        """ç”¨ä¾‹æ‰§è¡Œåé’©å­"""
        pass

    def on_test_failure(self, test_case, result):
        """æµ‹è¯•å¤±è´¥é’©å­"""
        pass

    def on_test_success(self, test_case, result):
        """æµ‹è¯•æˆåŠŸé’©å­"""
        pass

# ç¤ºä¾‹æ’ä»¶ï¼šæ€§èƒ½ç›‘æ§æ’ä»¶
class PerformanceMonitorPlugin(PluginBase):
    """æ€§èƒ½ç›‘æ§æ’ä»¶ç¤ºä¾‹"""

    def __init__(self):
        super().__init__()
        self.description = "ç›‘æ§æµ‹è¯•æ‰§è¡Œæ€§èƒ½ï¼Œæ”¶é›†å“åº”æ—¶é—´ç­‰æŒ‡æ ‡"
        self.performance_data = {}

    def before_case_execution(self, test_case):
        """è®°å½•ç”¨ä¾‹å¼€å§‹æ—¶é—´"""
        case_name = test_case.get('case_name', 'Unknown')
        self.performance_data[case_name] = {
            'start_time': time.time(),
            'memory_start': self._get_memory_usage()
        }

    def after_case_execution(self, test_case, result):
        """è®°å½•ç”¨ä¾‹ç»“æŸæ—¶é—´å’Œæ€§èƒ½æ•°æ®"""
        case_name = test_case.get('case_name', 'Unknown')

        if case_name in self.performance_data:
            end_time = time.time()
            start_data = self.performance_data[case_name]

            performance_metrics = {
                'execution_time': end_time - start_data['start_time'],
                'memory_usage': self._get_memory_usage() - start_data['memory_start'],
                'timestamp': datetime.now().isoformat()
            }

            # ä¿å­˜æ€§èƒ½æ•°æ®åˆ°ç»“æœ
            if hasattr(result, 'performance_metrics'):
                result.performance_metrics = performance_metrics

            logger.info(f"ç”¨ä¾‹ {case_name} æ€§èƒ½æ•°æ®: {performance_metrics}")

    def _get_memory_usage(self) -> float:
        """è·å–å½“å‰å†…å­˜ä½¿ç”¨é‡ï¼ˆMBï¼‰"""
        import psutil
        process = psutil.Process()
        return process.memory_info().rss / 1024 / 1024

    def after_test_execution(self, test_suite, results):
        """ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š"""
        performance_report = self._generate_performance_report(results)

        # ä¿å­˜æ€§èƒ½æŠ¥å‘Š
        report_file = Path("reports/performance_report.json")
        report_file.parent.mkdir(parents=True, exist_ok=True)

        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(performance_report, f, ensure_ascii=False, indent=2)

        logger.info(f"æ€§èƒ½æŠ¥å‘Šå·²ç”Ÿæˆ: {report_file}")

    def _generate_performance_report(self, results) -> Dict[str, Any]:
        """ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š"""
        performance_summary = {
            'total_cases': len(results),
            'average_execution_time': 0,
            'slowest_cases': [],
            'fastest_cases': [],
            'memory_usage_stats': {}
        }

        execution_times = []
        memory_usages = []

        for result in results:
            if hasattr(result, 'performance_metrics'):
                metrics = result.performance_metrics
                execution_times.append(metrics['execution_time'])
                memory_usages.append(metrics['memory_usage'])

        if execution_times:
            performance_summary['average_execution_time'] = sum(execution_times) / len(execution_times)
            performance_summary['max_execution_time'] = max(execution_times)
            performance_summary['min_execution_time'] = min(execution_times)

        if memory_usages:
            performance_summary['memory_usage_stats'] = {
                'average': sum(memory_usages) / len(memory_usages),
                'max': max(memory_usages),
                'min': min(memory_usages)
            }

        return performance_summary
````

### 8.2 è‡ªå®šä¹‰æ–­è¨€æ‰©å±•

```python
class CustomAssertionRegistry:
    """è‡ªå®šä¹‰æ–­è¨€æ³¨å†Œå™¨"""

    def __init__(self):
        self.custom_assertions = {}

    def register_assertion(self, name: str, assertion_func: callable):
        """æ³¨å†Œè‡ªå®šä¹‰æ–­è¨€"""
        self.custom_assertions[name] = assertion_func
        logger.info(f"æ³¨å†Œè‡ªå®šä¹‰æ–­è¨€: {name}")

    def execute_assertion(self, assertion_type: str, actual, expected, **kwargs):
        """æ‰§è¡Œæ–­è¨€"""
        if assertion_type in self.custom_assertions:
            assertion_func = self.custom_assertions[assertion_type]
            return assertion_func(actual, expected, **kwargs)
        else:
            raise ValueError(f"æœªçŸ¥çš„æ–­è¨€ç±»å‹: {assertion_type}")

# è‡ªå®šä¹‰æ–­è¨€ç¤ºä¾‹
def assert_response_time(actual_time: float, expected_max: float, **kwargs):
    """å“åº”æ—¶é—´æ–­è¨€"""
    if actual_time > expected_max:
        raise AssertionError(f"å“åº”æ—¶é—´è¶…å‡ºé¢„æœŸ: {actual_time}s > {expected_max}s")
    logger.info(f"å“åº”æ—¶é—´æ–­è¨€é€šè¿‡: {actual_time}s <= {expected_max}s")

def assert_json_schema(actual_data: dict, expected_schema: dict, **kwargs):
    """JSON Schemaæ–­è¨€"""
    import jsonschema

    try:
        jsonschema.validate(actual_data, expected_schema)
        logger.info("JSON Schemaæ–­è¨€é€šè¿‡")
    except jsonschema.ValidationError as e:
        raise AssertionError(f"JSON SchemaéªŒè¯å¤±è´¥: {e.message}")

def assert_database_record_count(table_name: str, expected_count: int, db_connection, **kwargs):
    """æ•°æ®åº“è®°å½•æ•°é‡æ–­è¨€"""
    cursor = db_connection.cursor()
    cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
    actual_count = cursor.fetchone()[0]

    if actual_count != expected_count:
        raise AssertionError(f"æ•°æ®åº“è®°å½•æ•°é‡ä¸åŒ¹é…: æœŸæœ› {expected_count}, å®é™… {actual_count}")

    logger.info(f"æ•°æ®åº“è®°å½•æ•°é‡æ–­è¨€é€šè¿‡: {table_name} æœ‰ {actual_count} æ¡è®°å½•")

# æ³¨å†Œè‡ªå®šä¹‰æ–­è¨€
assertion_registry = CustomAssertionRegistry()
assertion_registry.register_assertion('response_time', assert_response_time)
assertion_registry.register_assertion('json_schema', assert_json_schema)
assertion_registry.register_assertion('db_record_count', assert_database_record_count)
```

### 8.3 æ•°æ®æå–å™¨æ‰©å±•

```python
class CustomDataExtractorRegistry:
    """è‡ªå®šä¹‰æ•°æ®æå–å™¨æ³¨å†Œå™¨"""

    def __init__(self):
        self.extractors = {}

    def register_extractor(self, name: str, extractor_func: callable):
        """æ³¨å†Œè‡ªå®šä¹‰æ•°æ®æå–å™¨"""
        self.extractors[name] = extractor_func
        logger.info(f"æ³¨å†Œè‡ªå®šä¹‰æ•°æ®æå–å™¨: {name}")

    def extract_data(self, extractor_type: str, source_data, extraction_config: dict):
        """æ‰§è¡Œæ•°æ®æå–"""
        if extractor_type in self.extractors:
            extractor_func = self.extractors[extractor_type]
            return extractor_func(source_data, extraction_config)
        else:
            raise ValueError(f"æœªçŸ¥çš„æ•°æ®æå–å™¨ç±»å‹: {extractor_type}")

# è‡ªå®šä¹‰æ•°æ®æå–å™¨ç¤ºä¾‹
def extract_xml_xpath(source_data: str, config: dict):
    """XML XPathæ•°æ®æå–å™¨"""
    import xml.etree.ElementTree as ET

    xpath = config.get('xpath')
    if not xpath:
        raise ValueError("XML XPathæå–å™¨ç¼ºå°‘xpathé…ç½®")

    try:
        root = ET.fromstring(source_data)
        elements = root.findall(xpath)

        if config.get('multiple', False):
            return [elem.text for elem in elements]
        else:
            return elements[0].text if elements else None

    except Exception as e:
        logger.error(f"XML XPathæå–å¤±è´¥: {e}")
        return None

def extract_csv_column(source_data: str, config: dict):
    """CSVåˆ—æ•°æ®æå–å™¨"""
    import csv
    import io

    column_name = config.get('column')
    row_index = config.get('row_index', 0)

    if not column_name:
        raise ValueError("CSVåˆ—æå–å™¨ç¼ºå°‘columné…ç½®")

    try:
        csv_reader = csv.DictReader(io.StringIO(source_data))
        rows = list(csv_reader)

        if row_index < len(rows):
            return rows[row_index].get(column_name)
        else:
            logger.warning(f"CSVè¡Œç´¢å¼•è¶…å‡ºèŒƒå›´: {row_index}")
            return None

    except Exception as e:
        logger.error(f"CSVåˆ—æå–å¤±è´¥: {e}")
        return None

def extract_image_text_ocr(source_data: bytes, config: dict):
    """å›¾ç‰‡OCRæ–‡æœ¬æå–å™¨"""
    try:
        import pytesseract
        from PIL import Image
        import io

        # ä»å­—èŠ‚æ•°æ®åˆ›å»ºå›¾ç‰‡å¯¹è±¡
        image = Image.open(io.BytesIO(source_data))

        # OCRè¯†åˆ«
        lang = config.get('language', 'eng')
        text = pytesseract.image_to_string(image, lang=lang)

        # å¯é€‰çš„æ–‡æœ¬å¤„ç†
        if config.get('strip_whitespace', True):
            text = text.strip()

        return text

    except ImportError:
        logger.error("OCRåŠŸèƒ½éœ€è¦å®‰è£… pytesseract å’Œ Pillow")
        return None
    except Exception as e:
        logger.error(f"OCRæ–‡æœ¬æå–å¤±è´¥: {e}")
        return None

# æ³¨å†Œè‡ªå®šä¹‰æ•°æ®æå–å™¨
extractor_registry = CustomDataExtractorRegistry()
extractor_registry.register_extractor('xml_xpath', extract_xml_xpath)
extractor_registry.register_extractor('csv_column', extract_csv_column)
extractor_registry.register_extractor('image_ocr', extract_image_text_ocr)
```

---

## 9. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 9.1 æ‰§è¡Œæ€§èƒ½ä¼˜åŒ–

```python
class PerformanceOptimizer:
    """æ€§èƒ½ä¼˜åŒ–å™¨ - æå‡æ¡†æ¶æ‰§è¡Œæ•ˆç‡"""

    def __init__(self):
        self.connection_pools = {}
        self.cache_manager = CacheManager()
        self.resource_monitor = ResourceMonitor()

    def optimize_http_connections(self):
        """ä¼˜åŒ–HTTPè¿æ¥"""
        # ä½¿ç”¨è¿æ¥æ± å‡å°‘è¿æ¥å¼€é”€
        session = requests.Session()

        # é…ç½®è¿æ¥æ± 
        adapter = requests.adapters.HTTPAdapter(
            pool_connections=20,  # è¿æ¥æ± å¤§å°
            pool_maxsize=20,      # æœ€å¤§è¿æ¥æ•°
            max_retries=3,        # é‡è¯•æ¬¡æ•°
            pool_block=False      # éé˜»å¡æ¨¡å¼
        )

        session.mount('http://', adapter)
        session.mount('https://', adapter)

        # è®¾ç½®è¶…æ—¶
        session.timeout = (5, 30)  # è¿æ¥è¶…æ—¶5ç§’ï¼Œè¯»å–è¶…æ—¶30ç§’

        return session

    def optimize_browser_performance(self):
        """ä¼˜åŒ–æµè§ˆå™¨æ€§èƒ½"""
        browser_args = [
            '--no-sandbox',
            '--disable-dev-shm-usage',
            '--disable-gpu',
            '--disable-extensions',
            '--disable-plugins',
            '--disable-images',  # ç¦ç”¨å›¾ç‰‡åŠ è½½
            '--disable-javascript',  # å¯é€‰ï¼šç¦ç”¨JSï¼ˆå¦‚æœä¸éœ€è¦ï¼‰
            '--memory-pressure-off',
            '--max_old_space_size=4096'
        ]

        return {
            'headless': True,
            'args': browser_args,
            'viewport': {'width': 1280, 'height': 720}
        }

    def optimize_test_data_loading(self):
        """ä¼˜åŒ–æµ‹è¯•æ•°æ®åŠ è½½"""
        # å®ç°æ•°æ®é¢„åŠ è½½å’Œç¼“å­˜
        class DataCache:
            def __init__(self):
                self._cache = {}
                self._timestamps = {}

            def get_test_data(self, file_path: str):
                """è·å–æµ‹è¯•æ•°æ®ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
                file_mtime = os.path.getmtime(file_path)

                # æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
                if (file_path in self._cache and
                    file_path in self._timestamps and
                    self._timestamps[file_path] >= file_mtime):
                    return self._cache[file_path]

                # åŠ è½½æ•°æ®
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = yaml.safe_load(f)

                # æ›´æ–°ç¼“å­˜
                self._cache[file_path] = data
                self._timestamps[file_path] = file_mtime

                return data

        return DataCache()

class ResourceMonitor:
    """èµ„æºç›‘æ§å™¨"""

    def __init__(self):
        self.start_time = None
        self.peak_memory = 0
        self.cpu_usage_samples = []

    def start_monitoring(self):
        """å¼€å§‹ç›‘æ§"""
        self.start_time = time.time()
        self.peak_memory = 0
        self.cpu_usage_samples = []

        # å¯åŠ¨ç›‘æ§çº¿ç¨‹
        self.monitoring_thread = threading.Thread(target=self._monitor_resources)
        self.monitoring_thread.daemon = True
        self.monitoring_thread.start()

    def _monitor_resources(self):
        """ç›‘æ§èµ„æºä½¿ç”¨"""
        import psutil

        while True:
            try:
                # ç›‘æ§å†…å­˜ä½¿ç”¨
                memory_mb = psutil.virtual_memory().used / 1024 / 1024
                self.peak_memory = max(self.peak_memory, memory_mb)

                # ç›‘æ§CPUä½¿ç”¨
                cpu_percent = psutil.cpu_percent(interval=1)
                self.cpu_usage_samples.append(cpu_percent)

                # ä¿æŒæœ€è¿‘100ä¸ªæ ·æœ¬
                if len(self.cpu_usage_samples) > 100:
                    self.cpu_usage_samples.pop(0)

                time.sleep(5)  # æ¯5ç§’é‡‡æ ·ä¸€æ¬¡

            except Exception as e:
                logger.error(f"èµ„æºç›‘æ§å¼‚å¸¸: {e}")
                break

    def get_performance_report(self) -> Dict[str, Any]:
        """è·å–æ€§èƒ½æŠ¥å‘Š"""
        if not self.start_time:
            return {}

        execution_time = time.time() - self.start_time
        avg_cpu = sum(self.cpu_usage_samples) / len(self.cpu_usage_samples) if self.cpu_usage_samples else 0

        return {
            'execution_time': execution_time,
            'peak_memory_mb': self.peak_memory,
            'average_cpu_percent': avg_cpu,
            'cpu_samples_count': len(self.cpu_usage_samples)
        }

class CacheManager:
    """ç¼“å­˜ç®¡ç†å™¨"""

    def __init__(self):
        self.memory_cache = {}
        self.file_cache_dir = Path("temp/cache")
        self.file_cache_dir.mkdir(parents=True, exist_ok=True)

    def get_cached_response(self, cache_key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜çš„å“åº”"""
        # å…ˆæ£€æŸ¥å†…å­˜ç¼“å­˜
        if cache_key in self.memory_cache:
            cache_data = self.memory_cache[cache_key]
            if not self._is_cache_expired(cache_data):
                return cache_data['data']

        # æ£€æŸ¥æ–‡ä»¶ç¼“å­˜
        cache_file = self.file_cache_dir / f"{cache_key}.json"
        if cache_file.exists():
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    cache_data = json.load(f)

                if not self._is_cache_expired(cache_data):
                    # åŠ è½½åˆ°å†…å­˜ç¼“å­˜
                    self.memory_cache[cache_key] = cache_data
                    return cache_data['data']
                else:
                    # åˆ é™¤è¿‡æœŸçš„æ–‡ä»¶ç¼“å­˜
                    cache_file.unlink()

            except Exception as e:
                logger.warning(f"è¯»å–ç¼“å­˜æ–‡ä»¶å¤±è´¥: {cache_file}, é”™è¯¯: {e}")

        return None

    def set_cached_response(self, cache_key: str, data: Any, ttl: int = 3600):
        """è®¾ç½®ç¼“å­˜å“åº”"""
        cache_data = {
            'data': data,
            'timestamp': time.time(),
            'ttl': ttl
        }

        # ä¿å­˜åˆ°å†…å­˜ç¼“å­˜
        self.memory_cache[cache_key] = cache_data

        # ä¿å­˜åˆ°æ–‡ä»¶ç¼“å­˜
        cache_file = self.file_cache_dir / f"{cache_key}.json"
        try:
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, ensure_ascii=False, default=str)
        except Exception as e:
            logger.warning(f"ä¿å­˜ç¼“å­˜æ–‡ä»¶å¤±è´¥: {cache_file}, é”™è¯¯: {e}")

    def _is_cache_expired(self, cache_data: Dict) -> bool:
        """æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ"""
        current_time = time.time()
        cache_time = cache_data.get('timestamp', 0)
        ttl = cache_data.get('ttl', 3600)

        return (current_time - cache_time) > ttl

    def clear_cache(self):
        """æ¸…ç©ºç¼“å­˜"""
        self.memory_cache.clear()

        # æ¸…ç©ºæ–‡ä»¶ç¼“å­˜
        for cache_file in self.file_cache_dir.glob("*.json"):
            try:
                cache_file.unlink()
            except Exception as e:
                logger.warning(f"åˆ é™¤ç¼“å­˜æ–‡ä»¶å¤±è´¥: {cache_file}, é”™è¯¯: {e}")
```

### 9.2 å†…å­˜ä¼˜åŒ–ç­–ç•¥

````python
class MemoryOptimizer:
    """å†…å­˜ä¼˜åŒ–å™¨"""

    def __init__(self):
        self.large_objects = []
        self.memory_threshold = 500  # MB

    def optimize_test_results_storage(self):
        """ä¼˜åŒ–æµ‹è¯•ç»“æœå­˜å‚¨"""
        # ä½¿ç”¨ç”Ÿæˆå™¨å‡å°‘å†…å­˜å ç”¨
        def result_generator(results):
            for result in results:
                # åªä¿ç•™å¿…è¦çš„ä¿¡æ¯
                yield {
                    'case_name': result.case_name,
                    'status': result.status,
                    'error_message': result.error_message[:500] if result.error_message else None,  # é™åˆ¶é”™è¯¯ä¿¡æ¯é•¿åº¦
                    'execution_time': getattr(result, 'execution_time', None)
                }

        return result_generator

    def optimize_large_response_handling(self, response_data: Any) -> Any:
        """ä¼˜åŒ–å¤§å“åº”æ•°æ®å¤„ç†"""
        if isinstance(response_data, str) and len(response_data) > 1024 * 1024:  # 1MB
            # å¯¹äºå¤§æ–‡æœ¬å“åº”ï¼Œåªä¿ç•™æ‘˜è¦
            return {
                'type': 'large_text',
                'size': len(response_data),
                'preview': response_data[:1000] + '...' if len(response_data) > 1000 else response_data,
                'hash': hashlib.md5(response_data.encode()).hexdigest()
            }

        elif isinstance(response_data, bytes) and len(response_data) > 1024 * 1024:  # 1MB
            # å¯¹äºå¤§äºŒè¿›åˆ¶å“åº”ï¼Œåªä¿ç•™å…ƒä¿¡æ¯
            return {
                'type': 'large_binary',
                'size': len(response_data),
                'hash': hashlib.md5(response_data).hexdigest()
            }

        return response_data

    def monitor_memory_usage(self):
        """ç›‘æ§å†…å­˜ä½¿ç”¨"""
        import psutil

        memory_info = psutil.virtual_memory()
        memory_mb = memory_info.used / 1024 / 1024

        if memory_mb > self.memory_threshold:
            logger.warning(f"å†…å­˜ä½¿ç”¨è¿‡é«˜: {memory_mb:.1f}MB")
            self._trigger_garbage_collection()

    def _trigger_garbage_collection(self):
        """è§¦å‘åƒåœ¾å›æ”¶"""
        import gc

        # å¼ºåˆ¶åƒåœ¾å›æ”¶
        collected = gc.collect()
        logger.info(f"åƒåœ¾å›æ”¶å®Œæˆï¼Œå›æ”¶å¯¹è±¡æ•°: {collected}")

        # æ¸…ç†å¤§å¯¹è±¡å¼•ç”¨
        self.large_objects.clear()

class DatabaseOptimizer:
    """æ•°æ®åº“ä¼˜åŒ–å™¨"""

    def __init__(self):
        self.connection_pool = None
        self.query_cache = {}

    def create_connection_pool(self, db_config: Dict[str, Any]):
        """åˆ›å»ºæ•°æ®åº“è¿æ¥æ± """
        try:
            import pymysql
            from pymysql.pool import Pool

            self.connection_pool = Pool(
                host=db_config['host'],
                port=db_config['port'],
                user=db_config['username'],
                password=db_config['password'],
                database=db_config['database'],
                charset=db_config.get('charset', 'utf8mb4'),
                max_connections=db_config.get('max_connections', 10),
                blocking=True
            )

            logger.info("æ•°æ®åº“è¿æ¥æ± åˆ›å»ºæˆåŠŸ")

        except ImportError:
            logger.error("æ•°æ®åº“è¿æ¥æ± éœ€è¦å®‰è£… pymysql")
        except Exception as e:
            logger.error(f"æ•°æ®åº“è¿æ¥æ± åˆ›å»ºå¤±è´¥: {e}")

    def execute_query_with_cache(self, query: str, params: tuple = None, cache_ttl: int = 300):
        """æ‰§è¡Œå¸¦ç¼“å­˜çš„æŸ¥è¯¢"""
        # ç”Ÿæˆç¼“å­˜é”®
        cache_key = hashlib.md5(f"{query}:{params}".encode()).hexdigest()

        # æ£€æŸ¥ç¼“å­˜
        if cache_key in self.query_cache:
            cache_data = self.query_cache[cache_key]
            if time.time() - cache_data['timestamp'] < cache_ttl:
                logger.debug(f"ä½¿ç”¨ç¼“å­˜æŸ¥è¯¢ç»“æœ: {cache_key}")
                return cache_data['result']

        # æ‰§è¡ŒæŸ¥è¯¢
        try:
            connection = self.connection_pool.get_connection()
            cursor = connection.cursor()

            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)

            result = cursor.fetchall()

            # ç¼“å­˜ç»“æœ
            self.query_cache[cache_key] = {
                'result': result,
                'timestamp': time.time()
            }

            cursor.close()
            connection.close()

            return result

        except Exception as e:
            logger.error(f"æ•°æ®åº“æŸ¥è¯¢å¤±è´¥: {e}")
            raise

    def optimize_batch_operations(self, operations: List[Dict]):
        """ä¼˜åŒ–æ‰¹é‡æ“ä½œ"""
        # å°†æ“ä½œæŒ‰ç±»å‹åˆ†ç»„
        grouped_ops = {}
        for op in operations:
            op_type = op.get('type')
            if op_type not in grouped_ops:
                grouped_ops[op_type] = []
            grouped_ops[op_type].append(op)

        # æ‰¹é‡æ‰§è¡Œç›¸åŒç±»å‹çš„æ“ä½œ
        results = []
        for op_type, ops in grouped_ops.items():
            if op_type == 'insert':
                results.extend(self._batch_insert(ops))
            elif op_type == 'update':
                results.extend(self._batch_update(ops))
            elif op_type == 'delete':
                results.extend(self._batch_delete(ops))

        return results

    def _batch_insert(self, insert_ops: List[Dict]) -> List[Any]:
        """æ‰¹é‡æ’å…¥"""
        if not insert_ops:
            return []

        # æŒ‰è¡¨ååˆ†ç»„
        tables = {}
        for op in insert_ops:
            table = op['table']
            if table not in tables:
                tables[table] = []
            tables[table].append(op['data'])

        results = []
        for table, data_list in tables.items():
            try:
                connection = self.connection_pool.get_connection()
                cursor = connection.cursor()

                # æ„å»ºæ‰¹é‡æ’å…¥SQL
                if data_list:
                    columns = list(data_list[0].keys())
                    placeholders = ', '.join(['%s'] * len(columns))
                    sql = f"INSERT INTO {table} ({', '.join(columns)}) VALUES ({placeholders})"

                    # å‡†å¤‡æ•°æ®
                    values = [tuple(data[col] for col in columns) for data in data_list]

                    # æ‰§è¡Œæ‰¹é‡æ’å…¥
                    cursor.executemany(sql, values)
                    connection.commit()

                    results.append({'table': table, 'inserted': len(values)})

                cursor.close()
                connection.close()

            except Exception as e:
                logger.error(f"æ‰¹é‡æ’å…¥å¤±è´¥: {table}, é”™è¯¯: {e}")
                results.append({'table': table, 'error': str(e)})

        return results

---

## 10. æœ€ä½³å®è·µä¸è§„èŒƒ

### 10.1 ä»£ç è´¨é‡æ ‡å‡†

```python
"""
ä»£ç è´¨é‡æ ‡å‡†å’Œæœ€ä½³å®è·µ
"""

# 1. å‘½åè§„èŒƒ
class TestCaseNamingConvention:
    """æµ‹è¯•ç”¨ä¾‹å‘½åè§„èŒƒ"""

    @staticmethod
    def validate_case_name(case_name: str) -> bool:
        """
        éªŒè¯ç”¨ä¾‹åç§°æ˜¯å¦ç¬¦åˆè§„èŒƒ

        è§„èŒƒè¦æ±‚ï¼š
        - ä½¿ç”¨ä¸­æ–‡æè¿°ï¼Œæ¸…æ™°è¡¨è¾¾æµ‹è¯•ç›®çš„
        - æ ¼å¼ï¼š[æ¨¡å—]_[åŠŸèƒ½]_[åœºæ™¯]_[é¢„æœŸç»“æœ]
        - é•¿åº¦ä¸è¶…è¿‡50ä¸ªå­—ç¬¦
        - ä¸åŒ…å«ç‰¹æ®Šå­—ç¬¦
        """
        if not case_name:
            return False

        if len(case_name) > 50:
            return False

        # æ£€æŸ¥æ˜¯å¦åŒ…å«éæ³•å­—ç¬¦
        illegal_chars = ['<', '>', ':', '"', '|', '?', '*', '\\', '/']
        if any(char in case_name for char in illegal_chars):
            return False

        return True

    @staticmethod
    def generate_case_id(case_name: str) -> str:
        """ç”Ÿæˆç”¨ä¾‹ID"""
        import hashlib

        # ä½¿ç”¨MD5ç”Ÿæˆå”¯ä¸€ID
        case_id = hashlib.md5(case_name.encode('utf-8')).hexdigest()[:8]
        return f"TC_{case_id.upper()}"

# 2. é”™è¯¯å¤„ç†è§„èŒƒ
class ErrorHandlingStandards:
    """é”™è¯¯å¤„ç†æ ‡å‡†"""

    @staticmethod
    def handle_api_error(response: requests.Response, context: str = ""):
        """æ ‡å‡†APIé”™è¯¯å¤„ç†"""
        try:
            if response.status_code >= 400:
                error_info = {
                    'status_code': response.status_code,
                    'url': response.url,
                    'method': response.request.method,
                    'context': context,
                    'response_text': response.text[:500]  # é™åˆ¶é”™è¯¯ä¿¡æ¯é•¿åº¦
                }

                if response.headers.get('content-type', '').startswith('application/json'):
                    try:
                        error_info['response_json'] = response.json()
                    except:
                        pass

                raise APIError(f"APIè¯·æ±‚å¤±è´¥: {error_info}")

        except requests.exceptions.RequestException as e:
            raise APIError(f"ç½‘ç»œè¯·æ±‚å¼‚å¸¸: {e}")

    @staticmethod
    def handle_web_error(page, action: str, locator: str = ""):
        """æ ‡å‡†Webé”™è¯¯å¤„ç†"""
        try:
            # æ£€æŸ¥é¡µé¢æ˜¯å¦å¯ç”¨
            if page.is_closed():
                raise WebError("é¡µé¢å·²å…³é—­")

            # ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
            page.wait_for_load_state('networkidle', timeout=30000)

        except Exception as e:
            error_info = {
                'action': action,
                'locator': locator,
                'url': page.url if not page.is_closed() else 'Unknown',
                'error': str(e)
            }

            # è‡ªåŠ¨æˆªå›¾
            try:
                screenshot_path = f"screenshots/error_{int(time.time())}.png"
                page.screenshot(path=screenshot_path)
                error_info['screenshot'] = screenshot_path
            except:
                pass

            raise WebError(f"Webæ“ä½œå¤±è´¥: {error_info}")

# 3. æ—¥å¿—è®°å½•è§„èŒƒ
class LoggingStandards:
    """æ—¥å¿—è®°å½•æ ‡å‡†"""

    @staticmethod
    def log_test_step(step_name: str, action: str, params: Dict = None):
        """è®°å½•æµ‹è¯•æ­¥éª¤"""
        log_data = {
            'step': step_name,
            'action': action,
            'params': params or {},
            'timestamp': datetime.now().isoformat()
        }

        logger.info(f"æ‰§è¡Œæ­¥éª¤: {step_name}", extra={'step_data': log_data})

    @staticmethod
    def log_assertion(assertion_type: str, expected: Any, actual: Any, result: bool):
        """è®°å½•æ–­è¨€ç»“æœ"""
        log_data = {
            'assertion_type': assertion_type,
            'expected': expected,
            'actual': actual,
            'result': 'PASS' if result else 'FAIL',
            'timestamp': datetime.now().isoformat()
        }

        if result:
            logger.info(f"æ–­è¨€é€šè¿‡: {assertion_type}", extra={'assertion_data': log_data})
        else:
            logger.error(f"æ–­è¨€å¤±è´¥: {assertion_type}", extra={'assertion_data': log_data})

    @staticmethod
    def log_performance_metric(metric_name: str, value: float, unit: str = ""):
        """è®°å½•æ€§èƒ½æŒ‡æ ‡"""
        log_data = {
            'metric': metric_name,
            'value': value,
            'unit': unit,
            'timestamp': datetime.now().isoformat()
        }

        logger.info(f"æ€§èƒ½æŒ‡æ ‡: {metric_name}={value}{unit}", extra={'performance_data': log_data})

# 4. æµ‹è¯•æ•°æ®ç®¡ç†è§„èŒƒ
class TestDataStandards:
    """æµ‹è¯•æ•°æ®ç®¡ç†æ ‡å‡†"""

    @staticmethod
    def validate_test_data_structure(test_data: Dict) -> Tuple[bool, List[str]]:
        """éªŒè¯æµ‹è¯•æ•°æ®ç»“æ„"""
        errors = []

        # å¿…éœ€å­—æ®µæ£€æŸ¥
        required_fields = ['test_info', 'test_cases']
        for field in required_fields:
            if field not in test_data:
                errors.append(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")

        # test_infoç»“æ„æ£€æŸ¥
        if 'test_info' in test_data:
            test_info = test_data['test_info']
            required_info_fields = ['title', 'description']
            for field in required_info_fields:
                if field not in test_info:
                    errors.append(f"test_infoç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")

        # test_casesç»“æ„æ£€æŸ¥
        if 'test_cases' in test_data:
            test_cases = test_data['test_cases']
            if not isinstance(test_cases, list):
                errors.append("test_caseså¿…é¡»æ˜¯åˆ—è¡¨ç±»å‹")
            else:
                for i, case in enumerate(test_cases):
                    if not isinstance(case, dict):
                        errors.append(f"æµ‹è¯•ç”¨ä¾‹ {i} å¿…é¡»æ˜¯å­—å…¸ç±»å‹")
                        continue

                    if 'case_name' not in case:
                        errors.append(f"æµ‹è¯•ç”¨ä¾‹ {i} ç¼ºå°‘case_nameå­—æ®µ")

        return len(errors) == 0, errors

    @staticmethod
    def sanitize_test_data(data: Any) -> Any:
        """æ¸…ç†æµ‹è¯•æ•°æ®"""
        if isinstance(data, str):
            # ç§»é™¤æ•æ„Ÿä¿¡æ¯
            sensitive_patterns = [
                r'password["\']?\s*[:=]\s*["\']?[^"\']*["\']?',
                r'token["\']?\s*[:=]\s*["\']?[^"\']*["\']?',
                r'secret["\']?\s*[:=]\s*["\']?[^"\']*["\']?'
            ]

            for pattern in sensitive_patterns:
                data = re.sub(pattern, lambda m: m.group(0).split('=')[0] + '=***', data, flags=re.IGNORECASE)

            return data

        elif isinstance(data, dict):
            return {k: TestDataStandards.sanitize_test_data(v) for k, v in data.items()}

        elif isinstance(data, list):
            return [TestDataStandards.sanitize_test_data(item) for item in data]

        return data

# 5. é…ç½®ç®¡ç†è§„èŒƒ
class ConfigurationStandards:
    """é…ç½®ç®¡ç†æ ‡å‡†"""

    @staticmethod
    def validate_environment_config(env_config: Dict) -> Tuple[bool, List[str]]:
        """éªŒè¯ç¯å¢ƒé…ç½®"""
        errors = []

        # APIé…ç½®éªŒè¯
        if 'api' in env_config:
            api_config = env_config['api']

            # æ£€æŸ¥base_url
            base_url = api_config.get('base_url')
            if not base_url:
                errors.append("APIé…ç½®ç¼ºå°‘base_url")
            elif not (base_url.startswith('http://') or base_url.startswith('https://')):
                errors.append("API base_urlå¿…é¡»ä»¥http://æˆ–https://å¼€å¤´")

            # æ£€æŸ¥è¶…æ—¶é…ç½®
            timeout = api_config.get('timeout')
            if timeout and (not isinstance(timeout, (int, float)) or timeout <= 0):
                errors.append("API timeoutå¿…é¡»æ˜¯æ­£æ•°")

        # æ•°æ®åº“é…ç½®éªŒè¯
        if 'database' in env_config and env_config['database'].get('enabled'):
            db_config = env_config['database']
            required_db_fields = ['host', 'port', 'username', 'password', 'database']

            for field in required_db_fields:
                if not db_config.get(field):
                    errors.append(f"æ•°æ®åº“é…ç½®ç¼ºå°‘{field}")

            # ç«¯å£å·éªŒè¯
            port = db_config.get('port')
            if port and (not isinstance(port, int) or not (1 <= port <= 65535)):
                errors.append("æ•°æ®åº“ç«¯å£å·å¿…é¡»åœ¨1-65535èŒƒå›´å†…")

        return len(errors) == 0, errors

    @staticmethod
    def encrypt_sensitive_config(config: Dict) -> Dict:
        """åŠ å¯†æ•æ„Ÿé…ç½®"""
        from cryptography.fernet import Fernet

        # ç”Ÿæˆå¯†é’¥ï¼ˆå®é™…ä½¿ç”¨ä¸­åº”è¯¥å®‰å…¨å­˜å‚¨ï¼‰
        key = Fernet.generate_key()
        cipher = Fernet(key)

        sensitive_fields = ['password', 'secret', 'token', 'api_key']

        def encrypt_recursive(data):
            if isinstance(data, dict):
                result = {}
                for k, v in data.items():
                    if k.lower() in sensitive_fields and isinstance(v, str):
                        result[k] = cipher.encrypt(v.encode()).decode()
                    else:
                        result[k] = encrypt_recursive(v)
                return result
            elif isinstance(data, list):
                return [encrypt_recursive(item) for item in data]
            else:
                return data

        return encrypt_recursive(config)
````

### 10.2 å›¢é˜Ÿåä½œè§„èŒƒ

```python
class TeamCollaborationStandards:
    """å›¢é˜Ÿåä½œæ ‡å‡†"""

    @staticmethod
    def generate_code_review_checklist() -> List[str]:
        """ç”Ÿæˆä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•"""
        return [
            "âœ… ä»£ç æ˜¯å¦éµå¾ªé¡¹ç›®å‘½åè§„èŒƒï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰å……åˆ†çš„é”™è¯¯å¤„ç†ï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰å¿…è¦çš„æ—¥å¿—è®°å½•ï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰å•å…ƒæµ‹è¯•è¦†ç›–ï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰æ€§èƒ½è€ƒè™‘ï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰å®‰å…¨æ¼æ´ï¼Ÿ",
            "âœ… ä»£ç æ˜¯å¦æ˜“äºç†è§£å’Œç»´æŠ¤ï¼Ÿ",
            "âœ… æ˜¯å¦éµå¾ªDRYåŸåˆ™ï¼ˆä¸é‡å¤ä»£ç ï¼‰ï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰é€‚å½“çš„æ³¨é‡Šå’Œæ–‡æ¡£ï¼Ÿ",
            "âœ… æ˜¯å¦è€ƒè™‘äº†è¾¹ç•Œæ¡ä»¶ï¼Ÿ"
        ]

    @staticmethod
    def generate_test_case_review_checklist() -> List[str]:
        """ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹å®¡æŸ¥æ£€æŸ¥æ¸…å•"""
        return [
            "âœ… ç”¨ä¾‹åç§°æ˜¯å¦æ¸…æ™°æè¿°æµ‹è¯•ç›®çš„ï¼Ÿ",
            "âœ… æµ‹è¯•æ­¥éª¤æ˜¯å¦å®Œæ•´å’Œå‡†ç¡®ï¼Ÿ",
            "âœ… æ–­è¨€æ˜¯å¦å……åˆ†å’Œæœ‰æ•ˆï¼Ÿ",
            "âœ… æµ‹è¯•æ•°æ®æ˜¯å¦åˆç†å’Œå……åˆ†ï¼Ÿ",
            "âœ… æ˜¯å¦è¦†ç›–äº†æ­£å¸¸å’Œå¼‚å¸¸åœºæ™¯ï¼Ÿ",
            "âœ… æ˜¯å¦è€ƒè™‘äº†è¾¹ç•Œå€¼æµ‹è¯•ï¼Ÿ",
            "âœ… ç”¨ä¾‹æ˜¯å¦ç‹¬ç«‹ä¸”å¯é‡å¤æ‰§è¡Œï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰é€‚å½“çš„æ¸…ç†æ“ä½œï¼Ÿ",
            "âœ… æ‰§è¡Œæ—¶é—´æ˜¯å¦åœ¨åˆç†èŒƒå›´å†…ï¼Ÿ",
            "âœ… æ˜¯å¦æœ‰å¿…è¦çš„å‰ç½®æ¡ä»¶è¯´æ˜ï¼Ÿ"
        ]

    @staticmethod
    def create_test_execution_report_template() -> Dict[str, Any]:
        """åˆ›å»ºæµ‹è¯•æ‰§è¡ŒæŠ¥å‘Šæ¨¡æ¿"""
        return {
            "report_info": {
                "title": "è‡ªåŠ¨åŒ–æµ‹è¯•æ‰§è¡ŒæŠ¥å‘Š",
                "version": "1.0",
                "created_by": "",
                "created_date": datetime.now().strftime("%Y-%m-%d"),
                "execution_environment": ""
            },
            "summary": {
                "total_cases": 0,
                "passed_cases": 0,
                "failed_cases": 0,
                "skipped_cases": 0,
                "pass_rate": 0.0,
                "execution_time": "",
                "start_time": "",
                "end_time": ""
            },
            "environment_info": {
                "test_environment": "",
                "browser_version": "",
                "os_version": "",
                "framework_version": ""
            },
            "test_results": [],
            "failed_cases_analysis": [],
            "performance_metrics": {},
            "recommendations": []
        }

# 6. æŒç»­é›†æˆè§„èŒƒ
class CIStandards:
    """æŒç»­é›†æˆæ ‡å‡†"""

    @staticmethod
    def generate_jenkins_pipeline_template() -> str:
        """ç”ŸæˆJenkinsæµæ°´çº¿æ¨¡æ¿"""
        return """
pipeline {
    agent any

    parameters {
        choice(
            name: 'TEST_TYPE',
            choices: ['api', 'web', 'both'],
            description: 'é€‰æ‹©æµ‹è¯•ç±»å‹'
        )
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'test', 'staging'],
            description: 'é€‰æ‹©æµ‹è¯•ç¯å¢ƒ'
        )
        string(
            name: 'TEST_TAGS',
            defaultValue: 'smoke',
            description: 'æµ‹è¯•æ ‡ç­¾ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰'
        )
    }

    environment {
        ENV = "${params.ENVIRONMENT}"
        PYTHONPATH = "${WORKSPACE}"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        stage('Setup Environment') {
            steps {
                sh '''
                    python -m venv venv
                    source venv/bin/activate
                    pip install -r requirements.txt
                '''
            }
        }

        stage('Run Tests') {
            steps {
                sh '''
                    source venv/bin/activate
                    python main.py \\
                        --type ${TEST_TYPE} \\
                        --env ${ENVIRONMENT} \\
                        --tags ${TEST_TAGS} \\
                        --report both
                '''
            }
        }

        stage('Generate Reports') {
            steps {
                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: 'reports/html',
                    reportFiles: 'report.html',
                    reportName: 'Test Report'
                ])

                allure([
                    includeProperties: false,
                    jdk: '',
                    properties: [],
                    reportBuildPolicy: 'ALWAYS',
                    results: [[path: 'reports/allure-results']]
                ])
            }
        }

        stage('Send Notifications') {
            steps {
                script {
                    if (currentBuild.result == 'FAILURE') {
                        emailext (
                            subject: "æµ‹è¯•æ‰§è¡Œå¤±è´¥: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                            body: "æµ‹è¯•æ‰§è¡Œå¤±è´¥ï¼Œè¯·æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Š: ${env.BUILD_URL}",
                            to: "${env.CHANGE_AUTHOR_EMAIL}"
                        )
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}
        """

    @staticmethod
    def generate_github_actions_template() -> str:
        """ç”ŸæˆGitHub Actionsæ¨¡æ¿"""
        return """
name: Automated Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-type: [api, web]
        environment: [dev, test]

    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Install Playwright browsers
      if: matrix.test-type == 'web'
      run: playwright install

    - name: Run tests
      run: |
        python main.py \\
          --type ${{ matrix.test-type }} \\
          --env ${{ matrix.environment }} \\
          --tags smoke \\
          --report both
      env:
        ENV: ${{ matrix.environment }}

    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results-${{ matrix.test-type }}-${{ matrix.environment }}
        path: reports/

    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: success() || failure()
      with:
        name: Test Results (${{ matrix.test-type }}-${{ matrix.environment }})
        path: reports/junit.xml
        reporter: java-junit

    - name: Send notification
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: "æµ‹è¯•æ‰§è¡Œå¤±è´¥: ${{ matrix.test-type }} on ${{ matrix.environment }}"
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        """

# 7. è´¨é‡ä¿è¯è§„èŒƒ
class QualityAssuranceStandards:
    """è´¨é‡ä¿è¯æ ‡å‡†"""

    @staticmethod
    def calculate_test_coverage_metrics(test_results: List[TestResult]) -> Dict[str, float]:
        """è®¡ç®—æµ‹è¯•è¦†ç›–ç‡æŒ‡æ ‡"""
        total_cases = len(test_results)
        if total_cases == 0:
            return {}

        passed_cases = sum(1 for r in test_results if r.status == TestStatus.PASSED)
        failed_cases = sum(1 for r in test_results if r.status == TestStatus.FAILED)
        skipped_cases = sum(1 for r in test_results if r.status == TestStatus.SKIPPED)

        return {
            'pass_rate': (passed_cases / total_cases) * 100,
            'fail_rate': (failed_cases / total_cases) * 100,
            'skip_rate': (skipped_cases / total_cases) * 100,
            'execution_rate': ((passed_cases + failed_cases) / total_cases) * 100
        }

    @staticmethod
    def analyze_test_stability(historical_results: List[Dict]) -> Dict[str, Any]:
        """åˆ†ææµ‹è¯•ç¨³å®šæ€§"""
        if len(historical_results) < 2:
            return {"message": "éœ€è¦è‡³å°‘2æ¬¡æ‰§è¡Œè®°å½•æ‰èƒ½åˆ†æç¨³å®šæ€§"}

        # è®¡ç®—é€šè¿‡ç‡è¶‹åŠ¿
        pass_rates = [result.get('pass_rate', 0) for result in historical_results]

        # è®¡ç®—ç¨³å®šæ€§æŒ‡æ ‡
        avg_pass_rate = sum(pass_rates) / len(pass_rates)
        pass_rate_variance = sum((rate - avg_pass_rate) ** 2 for rate in pass_rates) / len(pass_rates)
        stability_score = max(0, 100 - (pass_rate_variance * 10))  # ç®€åŒ–çš„ç¨³å®šæ€§è¯„åˆ†

        # è¯†åˆ«ä¸ç¨³å®šçš„æµ‹è¯•ç”¨ä¾‹
        unstable_cases = []
        case_results = {}

        for result in historical_results:
            for case in result.get('test_cases', []):
                case_name = case.get('case_name')
                if case_name not in case_results:
                    case_results[case_name] = []
                case_results[case_name].append(case.get('status'))

        for case_name, statuses in case_results.items():
            if len(set(statuses)) > 1:  # çŠ¶æ€ä¸ä¸€è‡´
                failure_rate = statuses.count('FAILED') / len(statuses)
                if failure_rate > 0.2:  # å¤±è´¥ç‡è¶…è¿‡20%
                    unstable_cases.append({
                        'case_name': case_name,
                        'failure_rate': failure_rate,
                        'total_runs': len(statuses)
                    })

        return {
            'average_pass_rate': avg_pass_rate,
            'stability_score': stability_score,
            'unstable_cases': unstable_cases,
            'trend': 'improving' if pass_rates[-1] > pass_rates[0] else 'declining'
        }
```

---

## ğŸ“ æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†è‡ªåŠ¨åŒ–æµ‹è¯•æ¡†æ¶çš„å®Œæ•´å¼€å‘è¿‡ç¨‹ï¼Œä»æ¶æ„è®¾è®¡åˆ°å…·ä½“å®ç°ï¼Œä»æ ¸å¿ƒåŠŸèƒ½åˆ°æ‰©å±•æœºåˆ¶ï¼Œä¸ºå¼€å‘è€…æä¾›äº†å…¨é¢çš„æŠ€æœ¯æŒ‡å¯¼ã€‚

### ğŸ¯ æ ¸å¿ƒä»·å€¼

1. **ä¼ä¸šçº§æ¶æ„** - é‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼Œæ”¯æŒå¤§è§„æ¨¡å›¢é˜Ÿåä½œ
2. **å…³é”®å­—é©±åŠ¨** - é™ä½ç”¨ä¾‹ç¼–å†™é—¨æ§›ï¼Œæé«˜ç»´æŠ¤æ•ˆç‡
3. **é«˜åº¦å¯æ‰©å±•** - æ’ä»¶ç³»ç»Ÿæ”¯æŒåŠŸèƒ½å®šåˆ¶å’Œæ‰©å±•
4. **æ€§èƒ½ä¼˜åŒ–** - å¹¶å‘æ‰§è¡Œã€ç¼“å­˜æœºåˆ¶ã€èµ„æºç›‘æ§
5. **è´¨é‡ä¿è¯** - å®Œå–„çš„é”™è¯¯å¤„ç†ã€æ—¥å¿—è®°å½•ã€æµ‹è¯•æŠ¥å‘Š

### ğŸš€ å®æ–½å»ºè®®

1. **åˆ†é˜¶æ®µå®æ–½** - å…ˆå®ç°æ ¸å¿ƒåŠŸèƒ½ï¼Œå†é€æ­¥æ·»åŠ é«˜çº§ç‰¹æ€§
2. **å›¢é˜ŸåŸ¹è®­** - ç¡®ä¿å›¢é˜Ÿæˆå‘˜æŒæ¡æ¡†æ¶ä½¿ç”¨æ–¹æ³•
3. **æŒç»­ä¼˜åŒ–** - æ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µä¸æ–­æ”¹è¿›å’Œä¼˜åŒ–
4. **æ–‡æ¡£ç»´æŠ¤** - ä¿æŒæ–‡æ¡£ä¸ä»£ç åŒæ­¥æ›´æ–°
5. **ç¤¾åŒºå»ºè®¾** - å»ºç«‹å†…éƒ¨æŠ€æœ¯åˆ†äº«å’Œäº¤æµæœºåˆ¶

### ğŸ“ˆ å‘å±•æ–¹å‘

- **AI é›†æˆ** - æ™ºèƒ½ç”¨ä¾‹ç”Ÿæˆã€è‡ªåŠ¨åŒ–ç¼ºé™·åˆ†æ
- **äº‘åŸç”Ÿ** - å®¹å™¨åŒ–éƒ¨ç½²ã€å¾®æœåŠ¡æ¶æ„
- **å¯è§†åŒ–** - å›¾å½¢åŒ–ç”¨ä¾‹ç¼–è¾‘ã€å®æ—¶ç›‘æ§é¢æ¿
- **ç§»åŠ¨ç«¯æ”¯æŒ** - æ‰©å±•åˆ°ç§»åŠ¨åº”ç”¨æµ‹è¯•
- **æ€§èƒ½æµ‹è¯•** - é›†æˆæ€§èƒ½æµ‹è¯•èƒ½åŠ›

é€šè¿‡æœ¬æ¡†æ¶çš„å®æ–½ï¼Œå›¢é˜Ÿå¯ä»¥å»ºç«‹èµ·é«˜æ•ˆã€ç¨³å®šã€å¯ç»´æŠ¤çš„è‡ªåŠ¨åŒ–æµ‹è¯•ä½“ç³»ï¼Œä¸ºäº§å“è´¨é‡ä¿é©¾æŠ¤èˆªã€‚

---

## ğŸ“š é™„å½•

### A. å¿«é€Ÿå‚è€ƒ

#### A.1 å¸¸ç”¨å‘½ä»¤

```bash
# åŸºç¡€æ‰§è¡Œ
python main.py                          # æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
python main.py --type api              # ä»…æ‰§è¡ŒAPIæµ‹è¯•
python main.py --type web              # ä»…æ‰§è¡ŒWebæµ‹è¯•
python main.py --env test              # æŒ‡å®šæµ‹è¯•ç¯å¢ƒ
python main.py --tags smoke            # æ‰§è¡ŒæŒ‡å®šæ ‡ç­¾çš„ç”¨ä¾‹
python main.py --report allure         # ç”ŸæˆAllureæŠ¥å‘Š

# é«˜çº§é€‰é¡¹
python main.py --parallel              # å¹¶å‘æ‰§è¡Œ
python main.py --debug                 # è°ƒè¯•æ¨¡å¼
python main.py --dry-run              # å¹²è¿è¡Œæ¨¡å¼
python main.py --verbose              # è¯¦ç»†è¾“å‡º
```

#### A.2 é…ç½®æ–‡ä»¶æ¨¡æ¿

```yaml
# config.yaml æœ€å°é…ç½®
test_type: "both"
execution:
  concurrent:
    enabled: true
    max_workers: 4
report:
  type: "pytest-html"
logging:
  level: "INFO"
```

#### A.3 ç”¨ä¾‹æ¨¡æ¿

```yaml
# APIæµ‹è¯•ç”¨ä¾‹æ¨¡æ¿
test_info:
  title: "APIæµ‹è¯•æ¨¡æ¿"
  description: "APIæµ‹è¯•ç”¨ä¾‹æ¨¡æ¿"
  tags: ["api", "template"]

test_cases:
  - case_name: "APIè¯·æ±‚æµ‹è¯•"
    request:
      method: "GET"
      url: "/api/test"
    assertions:
      - type: "status_code"
        expected: 200

# Webæµ‹è¯•ç”¨ä¾‹æ¨¡æ¿
test_info:
  title: "Webæµ‹è¯•æ¨¡æ¿"
  description: "Webæµ‹è¯•ç”¨ä¾‹æ¨¡æ¿"
  tags: ["web", "template"]

test_cases:
  - case_name: "é¡µé¢è®¿é—®æµ‹è¯•"
    steps:
      - action: "navigate"
        params:
          url: "https://example.com"
      - action: "assert_element_visible"
        params:
          locator: "h1"
```

### B. æ•…éšœæ’é™¤

#### B.1 å¸¸è§é—®é¢˜

**é—®é¢˜ï¼šæµ‹è¯•æ‰§è¡Œå¤±è´¥ï¼Œæç¤ºæ¨¡å—æœªæ‰¾åˆ°**

```
è§£å†³æ–¹æ¡ˆï¼š
1. æ£€æŸ¥Pythonè·¯å¾„é…ç½®
2. ç¡®è®¤ä¾èµ–åŒ…å·²æ­£ç¡®å®‰è£…
3. éªŒè¯é¡¹ç›®æ ¹ç›®å½•è®¾ç½®
```

**é—®é¢˜ï¼šWeb æµ‹è¯•æµè§ˆå™¨å¯åŠ¨å¤±è´¥**

```
è§£å†³æ–¹æ¡ˆï¼š
1. å®‰è£…Playwrightæµè§ˆå™¨ï¼šplaywright install
2. æ£€æŸ¥ç³»ç»Ÿæƒé™è®¾ç½®
3. å°è¯•ä½¿ç”¨headlessæ¨¡å¼
```

**é—®é¢˜ï¼šå¹¶å‘æ‰§è¡Œæ—¶å‡ºç°èµ„æºå†²çª**

```
è§£å†³æ–¹æ¡ˆï¼š
1. å‡å°‘å¹¶å‘çº¿ç¨‹æ•°
2. æ£€æŸ¥æµ‹è¯•ç”¨ä¾‹ç‹¬ç«‹æ€§
3. å¢åŠ èµ„æºç­‰å¾…æ—¶é—´
```

#### B.2 æ€§èƒ½è°ƒä¼˜å»ºè®®

1. **å†…å­˜ä¼˜åŒ–**

   - é™åˆ¶å¤§å“åº”æ•°æ®çš„å­˜å‚¨
   - å®šæœŸæ¸…ç†ä¸´æ—¶æ–‡ä»¶
   - ä½¿ç”¨ç”Ÿæˆå™¨å¤„ç†å¤§æ•°æ®é›†

2. **æ‰§è¡Œæ•ˆç‡**

   - åˆç†è®¾ç½®å¹¶å‘æ•°é‡
   - å¯ç”¨ HTTP è¿æ¥æ± 
   - ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤æ“ä½œ

3. **èµ„æºç®¡ç†**
   - åŠæ—¶å…³é—­æµè§ˆå™¨å®ä¾‹
   - æ¸…ç†æ•°æ®åº“è¿æ¥
   - ç›‘æ§ç³»ç»Ÿèµ„æºä½¿ç”¨

### C. æ‰©å±•èµ„æº

#### C.1 ç›¸å…³æŠ€æœ¯æ–‡æ¡£

- [Pytest å®˜æ–¹æ–‡æ¡£](https://docs.pytest.org/)
- [Playwright æ–‡æ¡£](https://playwright.dev/python/)
- [Allure æŠ¥å‘Šæ–‡æ¡£](https://docs.qameta.io/allure/)
- [YAML è¯­æ³•æŒ‡å—](https://yaml.org/spec/1.2/spec.html)

#### C.2 æœ€ä½³å®è·µå‚è€ƒ

- [æµ‹è¯•é‡‘å­—å¡”ç†è®º](https://martinfowler.com/articles/practical-test-pyramid.html)
- [æŒç»­é›†æˆæœ€ä½³å®è·µ](https://www.thoughtworks.com/continuous-integration)
- [è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥](https://testautomationu.applitools.com/)

---

---

## 11. è‡ªå®šä¹‰æ¡†æ¶å¼€å‘æŒ‡å—

### 11.1 æ¡†æ¶è®¾è®¡å†³ç­–æ ‘

åœ¨å¼€å§‹è‡ªå®šä¹‰æ¡†æ¶å¼€å‘ä¹‹å‰ï¼Œéœ€è¦æ˜ç¡®ä»¥ä¸‹å…³é”®å†³ç­–ï¼š

```mermaid
graph TD
    A[å¼€å§‹æ¡†æ¶è®¾è®¡] --> B{æµ‹è¯•ç±»å‹éœ€æ±‚}
    B -->|ä»…APIæµ‹è¯•| C[è½»é‡çº§APIæ¡†æ¶]
    B -->|ä»…UIæµ‹è¯•| D[UIè‡ªåŠ¨åŒ–æ¡†æ¶]
    B -->|æ··åˆæµ‹è¯•| E[å…¨æ ˆæµ‹è¯•æ¡†æ¶]

    C --> F{å›¢é˜ŸæŠ€æœ¯æ ˆ}
    D --> F
    E --> F

    F -->|Python| G[åŸºäºPythonç”Ÿæ€]
    F -->|Java| H[åŸºäºJavaç”Ÿæ€]
    F -->|JavaScript| I[åŸºäºNode.jsç”Ÿæ€]
    F -->|å…¶ä»–| J[è·¨è¯­è¨€æ–¹æ¡ˆ]

    G --> K[é€‰æ‹©æ ¸å¿ƒåº“]
    H --> K
    I --> K
    J --> K

    K --> L[æ¶æ„è®¾è®¡]
    L --> M[åŸå‹å¼€å‘]
    M --> N[è¿­ä»£å®Œå–„]
```

### 11.2 æ¡†æ¶å¼€å‘è·¯çº¿å›¾

#### é˜¶æ®µä¸€ï¼šéœ€æ±‚åˆ†æä¸æŠ€æœ¯é€‰å‹ï¼ˆ1-2 å‘¨ï¼‰

```python
class FrameworkRequirementAnalysis:
    """æ¡†æ¶éœ€æ±‚åˆ†æå·¥å…·"""

    def __init__(self):
        self.requirements = {}
        self.constraints = {}
        self.stakeholders = {}

    def analyze_testing_needs(self) -> Dict[str, Any]:
        """åˆ†ææµ‹è¯•éœ€æ±‚"""
        analysis_questions = {
            "æµ‹è¯•ç±»å‹": [
                "ä¸»è¦æµ‹è¯•APIæ¥å£è¿˜æ˜¯Webç•Œé¢ï¼Ÿ",
                "æ˜¯å¦éœ€è¦ç§»åŠ¨ç«¯æµ‹è¯•æ”¯æŒï¼Ÿ",
                "æ˜¯å¦éœ€è¦æ€§èƒ½æµ‹è¯•èƒ½åŠ›ï¼Ÿ",
                "æ˜¯å¦éœ€è¦æ•°æ®åº“æµ‹è¯•ï¼Ÿ"
            ],
            "å›¢é˜Ÿæƒ…å†µ": [
                "å›¢é˜Ÿè§„æ¨¡å’ŒæŠ€æœ¯æ°´å¹³ï¼Ÿ",
                "ä¸»è¦ä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€ï¼Ÿ",
                "ç°æœ‰çš„æµ‹è¯•å·¥å…·å’Œæµç¨‹ï¼Ÿ",
                "CI/CDé›†æˆéœ€æ±‚ï¼Ÿ"
            ],
            "ä¸šåŠ¡éœ€æ±‚": [
                "æµ‹è¯•æ‰§è¡Œé¢‘ç‡ï¼Ÿ",
                "æŠ¥å‘Šå’Œé€šçŸ¥éœ€æ±‚ï¼Ÿ",
                "å¤šç¯å¢ƒæ”¯æŒéœ€æ±‚ï¼Ÿ",
                "åˆè§„å’Œå®‰å…¨è¦æ±‚ï¼Ÿ"
            ],
            "æŠ€æœ¯çº¦æŸ": [
                "æ€§èƒ½è¦æ±‚ï¼ˆæ‰§è¡Œé€Ÿåº¦ã€å¹¶å‘æ•°ï¼‰ï¼Ÿ",
                "å¯ç»´æŠ¤æ€§è¦æ±‚ï¼Ÿ",
                "æ‰©å±•æ€§è¦æ±‚ï¼Ÿ",
                "é¢„ç®—å’Œæ—¶é—´é™åˆ¶ï¼Ÿ"
            ]
        }

        return analysis_questions

    def recommend_tech_stack(self, requirements: Dict) -> Dict[str, List[str]]:
        """æ¨èæŠ€æœ¯æ ˆ"""
        recommendations = {
            "è½»é‡çº§APIæ¡†æ¶": [
                "æ ¸å¿ƒåº“ï¼šrequests + pytest",
                "é…ç½®ï¼šYAML/JSON",
                "æŠ¥å‘Šï¼špytest-html",
                "é€‚ç”¨ï¼šå°å›¢é˜Ÿï¼Œç®€å•APIæµ‹è¯•"
            ],
            "ä¼ä¸šçº§å…¨æ ˆæ¡†æ¶": [
                "æ ¸å¿ƒåº“ï¼šrequests + playwright + pytest",
                "é…ç½®ï¼šå¤šå±‚é…ç½®ç³»ç»Ÿ",
                "æŠ¥å‘Šï¼šAllure + è‡ªå®šä¹‰æŠ¥å‘Š",
                "æ‰©å±•ï¼šæ’ä»¶ç³»ç»Ÿ",
                "é€‚ç”¨ï¼šå¤§å›¢é˜Ÿï¼Œå¤æ‚æµ‹è¯•éœ€æ±‚"
            ],
            "äº‘åŸç”Ÿæ¡†æ¶": [
                "æ ¸å¿ƒåº“ï¼šåŸºç¡€æ¡†æ¶ + Docker",
                "éƒ¨ç½²ï¼šKubernetes",
                "ç›‘æ§ï¼šPrometheus + Grafana",
                "é€‚ç”¨ï¼šå¾®æœåŠ¡æ¶æ„ï¼Œå¤§è§„æ¨¡æµ‹è¯•"
            ]
        }

        return recommendations

# æŠ€æœ¯é€‰å‹å†³ç­–çŸ©é˜µ
TECH_DECISION_MATRIX = {
    "æµ‹è¯•åº“é€‰æ‹©": {
        "pytest": {
            "ä¼˜åŠ¿": ["ç”Ÿæ€ä¸°å¯Œ", "æ’ä»¶å¤š", "ç¤¾åŒºæ´»è·ƒ"],
            "åŠ£åŠ¿": ["å­¦ä¹ æ›²çº¿", "é…ç½®å¤æ‚"],
            "é€‚ç”¨åœºæ™¯": "Pythoné¡¹ç›®ï¼Œéœ€è¦ä¸°å¯Œæ’ä»¶"
        },
        "unittest": {
            "ä¼˜åŠ¿": ["å†…ç½®åº“", "ç®€å•ç›´æ¥", "æ— ä¾èµ–"],
            "åŠ£åŠ¿": ["åŠŸèƒ½æœ‰é™", "æ‰©å±•æ€§å·®"],
            "é€‚ç”¨åœºæ™¯": "ç®€å•é¡¹ç›®ï¼Œå¿«é€Ÿå¼€å§‹"
        },
        "è‡ªå®šä¹‰æ¡†æ¶": {
            "ä¼˜åŠ¿": ["å®Œå…¨æ§åˆ¶", "å®šåˆ¶åŒ–å¼º"],
            "åŠ£åŠ¿": ["å¼€å‘æˆæœ¬é«˜", "ç»´æŠ¤å¤æ‚"],
            "é€‚ç”¨åœºæ™¯": "ç‰¹æ®Šéœ€æ±‚ï¼Œç°æœ‰æ¡†æ¶æ— æ³•æ»¡è¶³"
        }
    },
    "HTTPåº“é€‰æ‹©": {
        "requests": {
            "ä¼˜åŠ¿": ["ç®€å•æ˜“ç”¨", "åŠŸèƒ½å®Œæ•´", "æ–‡æ¡£ä¸°å¯Œ"],
            "åŠ£åŠ¿": ["åŒæ­¥æ‰§è¡Œ", "æ€§èƒ½ä¸€èˆ¬"],
            "é€‚ç”¨åœºæ™¯": "å¸¸è§„APIæµ‹è¯•"
        },
        "httpx": {
            "ä¼˜åŠ¿": ["å¼‚æ­¥æ”¯æŒ", "HTTP/2æ”¯æŒ", "ç°ä»£è®¾è®¡"],
            "åŠ£åŠ¿": ["ç›¸å¯¹è¾ƒæ–°", "ç”Ÿæ€è¾ƒå°"],
            "é€‚ç”¨åœºæ™¯": "é«˜æ€§èƒ½éœ€æ±‚ï¼Œå¼‚æ­¥æµ‹è¯•"
        },
        "aiohttp": {
            "ä¼˜åŠ¿": ["å¼‚æ­¥é«˜æ€§èƒ½", "WebSocketæ”¯æŒ"],
            "åŠ£åŠ¿": ["ä»…å¼‚æ­¥", "å­¦ä¹ æˆæœ¬é«˜"],
            "é€‚ç”¨åœºæ™¯": "é«˜å¹¶å‘æµ‹è¯•"
        }
    }
}
```

#### é˜¶æ®µäºŒï¼šæ ¸å¿ƒæ¶æ„è®¾è®¡ï¼ˆ2-3 å‘¨ï¼‰

```python
class CustomFrameworkArchitect:
    """è‡ªå®šä¹‰æ¡†æ¶æ¶æ„å¸ˆ"""

    def design_core_architecture(self) -> Dict[str, Any]:
        """è®¾è®¡æ ¸å¿ƒæ¶æ„"""
        architecture = {
            "åˆ†å±‚è®¾è®¡": {
                "è¡¨ç°å±‚": "CLI/Webç•Œé¢",
                "åº”ç”¨å±‚": "æµ‹è¯•ç¼–æ’å’Œæ‰§è¡Œ",
                "ä¸šåŠ¡å±‚": "æµ‹è¯•é€»è¾‘å’Œå…³é”®å­—",
                "æ•°æ®å±‚": "é…ç½®å’Œæµ‹è¯•æ•°æ®",
                "åŸºç¡€è®¾æ–½å±‚": "æ—¥å¿—ã€ç¼“å­˜ã€é€šçŸ¥"
            },
            "æ ¸å¿ƒç»„ä»¶": {
                "é…ç½®ç®¡ç†å™¨": "ç»Ÿä¸€é…ç½®å…¥å£",
                "æµ‹è¯•æ‰§è¡Œå™¨": "ç”¨ä¾‹æ‰§è¡Œå¼•æ“",
                "å…³é”®å­—å¼•æ“": "å…³é”®å­—é©±åŠ¨æ ¸å¿ƒ",
                "æŠ¥å‘Šç”Ÿæˆå™¨": "å¤šæ ¼å¼æŠ¥å‘Š",
                "é€šçŸ¥ç³»ç»Ÿ": "ç»“æœé€šçŸ¥",
                "æ’ä»¶ç³»ç»Ÿ": "æ‰©å±•æœºåˆ¶"
            },
            "è®¾è®¡æ¨¡å¼": {
                "å·¥å‚æ¨¡å¼": "åˆ›å»ºä¸åŒç±»å‹çš„æ‰§è¡Œå™¨",
                "ç­–ç•¥æ¨¡å¼": "ä¸åŒçš„æŠ¥å‘Šç”Ÿæˆç­–ç•¥",
                "è§‚å¯Ÿè€…æ¨¡å¼": "æµ‹è¯•äº‹ä»¶é€šçŸ¥",
                "å»ºé€ è€…æ¨¡å¼": "å¤æ‚å¯¹è±¡æ„å»º",
                "å•ä¾‹æ¨¡å¼": "å…¨å±€é…ç½®ç®¡ç†"
            }
        }

        return architecture

    def create_project_structure(self) -> str:
        """åˆ›å»ºé¡¹ç›®ç»“æ„æ¨¡æ¿"""
        structure = """
my_test_framework/
â”œâ”€â”€ README.md                    # é¡¹ç›®è¯´æ˜
â”œâ”€â”€ requirements.txt            # ä¾èµ–åˆ—è¡¨
â”œâ”€â”€ setup.py                    # å®‰è£…è„šæœ¬
â”œâ”€â”€ pyproject.toml             # é¡¹ç›®é…ç½®
â”œâ”€â”€ .gitignore                 # Gitå¿½ç•¥æ–‡ä»¶
â”œâ”€â”€ .github/                   # GitHub Actions
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ ci.yml
â”œâ”€â”€ docs/                      # æ–‡æ¡£ç›®å½•
â”‚   â”œâ”€â”€ user_guide.md
â”‚   â”œâ”€â”€ developer_guide.md
â”‚   â””â”€â”€ api_reference.md
â”œâ”€â”€ src/                       # æºä»£ç ç›®å½•
â”‚   â””â”€â”€ my_framework/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ core/              # æ ¸å¿ƒæ¨¡å—
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ config.py      # é…ç½®ç®¡ç†
â”‚       â”‚   â”œâ”€â”€ executor.py    # æ‰§è¡Œå¼•æ“
â”‚       â”‚   â”œâ”€â”€ keywords.py    # å…³é”®å­—å¼•æ“
â”‚       â”‚   â””â”€â”€ reporter.py    # æŠ¥å‘Šç”Ÿæˆ
â”‚       â”œâ”€â”€ utils/             # å·¥å…·æ¨¡å—
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ logger.py      # æ—¥å¿—å·¥å…·
â”‚       â”‚   â”œâ”€â”€ helpers.py     # è¾…åŠ©å‡½æ•°
â”‚       â”‚   â””â”€â”€ validators.py  # éªŒè¯å·¥å…·
â”‚       â”œâ”€â”€ plugins/           # æ’ä»¶ç›®å½•
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â””â”€â”€ base.py        # æ’ä»¶åŸºç±»
â”‚       â””â”€â”€ cli/               # å‘½ä»¤è¡Œæ¥å£
â”‚           â”œâ”€â”€ __init__.py
â”‚           â””â”€â”€ main.py        # ä¸»å…¥å£
â”œâ”€â”€ tests/                     # æµ‹è¯•ç›®å½•
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ unit/                  # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ integration/           # é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ fixtures/              # æµ‹è¯•æ•°æ®
â”œâ”€â”€ examples/                  # ç¤ºä¾‹ç›®å½•
â”‚   â”œâ”€â”€ basic_usage/
â”‚   â”œâ”€â”€ advanced_features/
â”‚   â””â”€â”€ custom_plugins/
â””â”€â”€ scripts/                   # è„šæœ¬ç›®å½•
    â”œâ”€â”€ build.sh
    â”œâ”€â”€ test.sh
    â””â”€â”€ deploy.sh
        """
        return structure

    def generate_core_interfaces(self) -> Dict[str, str]:
        """ç”Ÿæˆæ ¸å¿ƒæ¥å£å®šä¹‰"""
        interfaces = {
            "æµ‹è¯•æ‰§è¡Œå™¨æ¥å£": '''
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class TestExecutorInterface(ABC):
    """æµ‹è¯•æ‰§è¡Œå™¨æ¥å£"""

    @abstractmethod
    def execute_test_case(self, test_case: Dict[str, Any]) -> 'TestResult':
        """æ‰§è¡Œå•ä¸ªæµ‹è¯•ç”¨ä¾‹"""
        pass

    @abstractmethod
    def execute_test_suite(self, test_suite: List[Dict]) -> List['TestResult']:
        """æ‰§è¡Œæµ‹è¯•å¥—ä»¶"""
        pass

    @abstractmethod
    def setup(self) -> None:
        """æ‰§è¡Œå‰å‡†å¤‡"""
        pass

    @abstractmethod
    def teardown(self) -> None:
        """æ‰§è¡Œåæ¸…ç†"""
        pass
            ''',

            "å…³é”®å­—æ¥å£": '''
from abc import ABC, abstractmethod
from typing import Any, Dict

class KeywordInterface(ABC):
    """å…³é”®å­—æ¥å£"""

    @abstractmethod
    def execute(self, action: str, params: Dict[str, Any]) -> Any:
        """æ‰§è¡Œå…³é”®å­—"""
        pass

    @abstractmethod
    def get_supported_actions(self) -> List[str]:
        """è·å–æ”¯æŒçš„åŠ¨ä½œåˆ—è¡¨"""
        pass

    @abstractmethod
    def validate_params(self, action: str, params: Dict[str, Any]) -> bool:
        """éªŒè¯å‚æ•°"""
        pass
            ''',

            "æŠ¥å‘Šç”Ÿæˆå™¨æ¥å£": '''
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class ReporterInterface(ABC):
    """æŠ¥å‘Šç”Ÿæˆå™¨æ¥å£"""

    @abstractmethod
    def generate_report(self, test_results: List['TestResult']) -> str:
        """ç”ŸæˆæŠ¥å‘Š"""
        pass

    @abstractmethod
    def get_report_format(self) -> str:
        """è·å–æŠ¥å‘Šæ ¼å¼"""
        pass

    @abstractmethod
    def configure(self, config: Dict[str, Any]) -> None:
        """é…ç½®æŠ¥å‘Šç”Ÿæˆå™¨"""
        pass
            '''
        }

        return interfaces
```

#### é˜¶æ®µä¸‰ï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ˆ4-6 å‘¨ï¼‰

````python
class FrameworkImplementationGuide:
    """æ¡†æ¶å®ç°æŒ‡å—"""

    def implement_config_system(self) -> str:
        """å®ç°é…ç½®ç³»ç»Ÿ"""
        return '''
# ç¬¬ä¸€æ­¥ï¼šå®šä¹‰é…ç½®æ¨¡å‹
from dataclasses import dataclass
from typing import Optional, Dict, Any
import yaml
import os

@dataclass
class APIConfig:
    base_url: str
    timeout: int = 30
    retry_times: int = 3
    headers: Dict[str, str] = None

@dataclass
class WebConfig:
    browser: str = "chromium"
    headless: bool = False
    viewport_width: int = 1920
    viewport_height: int = 1080

@dataclass
class FrameworkConfig:
    api: APIConfig
    web: WebConfig
    log_level: str = "INFO"
    parallel: bool = False
    max_workers: int = 4

# ç¬¬äºŒæ­¥ï¼šå®ç°é…ç½®åŠ è½½å™¨
class ConfigLoader:
    def __init__(self, config_path: str = "config.yaml"):
        self.config_path = config_path
        self._config = None

    def load(self) -> FrameworkConfig:
        """åŠ è½½é…ç½®"""
        if not os.path.exists(self.config_path):
            return self._create_default_config()

        with open(self.config_path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)

        return self._parse_config(config_data)

    def _create_default_config(self) -> FrameworkConfig:
        """åˆ›å»ºé»˜è®¤é…ç½®"""
        return FrameworkConfig(
            api=APIConfig(base_url="http://localhost:8080"),
            web=WebConfig()
        )

    def _parse_config(self, config_data: Dict) -> FrameworkConfig:
        """è§£æé…ç½®æ•°æ®"""
        api_config = APIConfig(**config_data.get('api', {}))
        web_config = WebConfig(**config_data.get('web', {}))

        return FrameworkConfig(
            api=api_config,
            web=web_config,
            log_level=config_data.get('log_level', 'INFO'),
            parallel=config_data.get('parallel', False),
            max_workers=config_data.get('max_workers', 4)
        )

# ç¬¬ä¸‰æ­¥ï¼šé…ç½®éªŒè¯
class ConfigValidator:
    @staticmethod
    def validate(config: FrameworkConfig) -> List[str]:
        """éªŒè¯é…ç½®"""
        errors = []

        # éªŒè¯APIé…ç½®
        if not config.api.base_url:
            errors.append("API base_urlä¸èƒ½ä¸ºç©º")

        if config.api.timeout <= 0:
            errors.append("API timeoutå¿…é¡»å¤§äº0")

        # éªŒè¯Webé…ç½®
        if config.web.browser not in ['chromium', 'firefox', 'webkit']:
            errors.append("ä¸æ”¯æŒçš„æµè§ˆå™¨ç±»å‹")

        return errors
        '''

    def implement_test_executor(self) -> str:
        """å®ç°æµ‹è¯•æ‰§è¡Œå™¨"""
        return '''
# åŸºç¡€æµ‹è¯•æ‰§è¡Œå™¨
class BaseTestExecutor:
    def __init__(self, config: FrameworkConfig):
        self.config = config
        self.logger = self._setup_logger()
        self.results = []

    def execute_test_case(self, test_case: Dict[str, Any]) -> TestResult:
        """æ‰§è¡Œå•ä¸ªæµ‹è¯•ç”¨ä¾‹"""
        case_name = test_case.get('case_name', 'Unknown')
        result = TestResult(case_name)

        try:
            self.logger.info(f"å¼€å§‹æ‰§è¡Œç”¨ä¾‹: {case_name}")

            # æ‰§è¡Œå‰ç½®æ¡ä»¶
            self._execute_setup(test_case)

            # æ‰§è¡Œæµ‹è¯•æ­¥éª¤
            self._execute_test_steps(test_case, result)

            # æ‰§è¡Œæ–­è¨€
            self._execute_assertions(test_case, result)

            result.status = TestStatus.PASSED
            self.logger.info(f"ç”¨ä¾‹æ‰§è¡ŒæˆåŠŸ: {case_name}")

        except Exception as e:
            result.status = TestStatus.FAILED
            result.error_message = str(e)
            self.logger.error(f"ç”¨ä¾‹æ‰§è¡Œå¤±è´¥: {case_name}, é”™è¯¯: {e}")

        finally:
            # æ‰§è¡Œæ¸…ç†
            self._execute_teardown(test_case)

        return result

    def _execute_test_steps(self, test_case: Dict, result: TestResult):
        """æ‰§è¡Œæµ‹è¯•æ­¥éª¤"""
        steps = test_case.get('steps', [])

        for step in steps:
            action = step.get('action')
            params = step.get('params', {})

            # æ ¹æ®åŠ¨ä½œç±»å‹é€‰æ‹©æ‰§è¡Œå™¨
            if action.startswith('api_'):
                self._execute_api_step(action, params, result)
            elif action.startswith('web_'):
                self._execute_web_step(action, params, result)
            else:
                raise ValueError(f"ä¸æ”¯æŒçš„åŠ¨ä½œç±»å‹: {action}")

    def _execute_api_step(self, action: str, params: Dict, result: TestResult):
        """æ‰§è¡ŒAPIæ­¥éª¤"""
        # å®ç°APIæ­¥éª¤æ‰§è¡Œé€»è¾‘
        pass

    def _execute_web_step(self, action: str, params: Dict, result: TestResult):
        """æ‰§è¡ŒWebæ­¥éª¤"""
        # å®ç°Webæ­¥éª¤æ‰§è¡Œé€»è¾‘
        pass

# å¹¶å‘æµ‹è¯•æ‰§è¡Œå™¨
from concurrent.futures import ThreadPoolExecutor, as_completed

class ConcurrentTestExecutor(BaseTestExecutor):
    def execute_test_suite(self, test_cases: List[Dict]) -> List[TestResult]:
        """å¹¶å‘æ‰§è¡Œæµ‹è¯•å¥—ä»¶"""
        if not self.config.parallel:
            return self._execute_sequential(test_cases)

        return self._execute_concurrent(test_cases)

    def _execute_concurrent(self, test_cases: List[Dict]) -> List[TestResult]:
        """å¹¶å‘æ‰§è¡Œ"""
        results = []

        with ThreadPoolExecutor(max_workers=self.config.max_workers) as executor:
            # æäº¤æ‰€æœ‰ä»»åŠ¡
            future_to_case = {
                executor.submit(self.execute_test_case, case): case
                for case in test_cases
            }

            # æ”¶é›†ç»“æœ
            for future in as_completed(future_to_case):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    case = future_to_case[future]
                    error_result = TestResult(case.get('case_name', 'Unknown'))
                    error_result.status = TestStatus.FAILED
                    error_result.error_message = str(e)
                    results.append(error_result)

        return results
        '''

    def implement_keyword_engine(self) -> str:
        """å®ç°å…³é”®å­—å¼•æ“"""
        return '''
# å…³é”®å­—æ³¨å†Œå™¨
class KeywordRegistry:
    def __init__(self):
        self._keywords = {}

    def register(self, name: str, keyword_func: callable):
        """æ³¨å†Œå…³é”®å­—"""
        self._keywords[name] = keyword_func

    def execute(self, name: str, params: Dict[str, Any]) -> Any:
        """æ‰§è¡Œå…³é”®å­—"""
        if name not in self._keywords:
            raise KeywordNotFoundError(f"å…³é”®å­— '{name}' æœªæ‰¾åˆ°")

        keyword_func = self._keywords[name]
        return keyword_func(**params)

    def get_all_keywords(self) -> List[str]:
        """è·å–æ‰€æœ‰å…³é”®å­—"""
        return list(self._keywords.keys())

# å…³é”®å­—è£…é¥°å™¨
def keyword(name: str = None):
    """å…³é”®å­—è£…é¥°å™¨"""
    def decorator(func):
        keyword_name = name or func.__name__
        # å°†å‡½æ•°æ³¨å†Œåˆ°å…¨å±€æ³¨å†Œå™¨
        global_registry.register(keyword_name, func)
        return func
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@keyword("send_get_request")
def send_get_request(url: str, headers: Dict = None) -> requests.Response:
    """å‘é€GETè¯·æ±‚å…³é”®å­—"""
    return requests.get(url, headers=headers or {})

@keyword("assert_status_code")
def assert_status_code(response: requests.Response, expected: int):
    """æ–­è¨€çŠ¶æ€ç å…³é”®å­—"""
    if response.status_code != expected:
        raise AssertionError(f"çŠ¶æ€ç ä¸åŒ¹é…: æœŸæœ› {expected}, å®é™… {response.status_code}")

# å…³é”®å­—å¼•æ“
class KeywordEngine:
    def __init__(self, registry: KeywordRegistry):
        self.registry = registry
        self.context = {}  # æ‰§è¡Œä¸Šä¸‹æ–‡

    def execute_keyword(self, keyword_def: Dict[str, Any]) -> Any:
        """æ‰§è¡Œå…³é”®å­—å®šä¹‰"""
        action = keyword_def.get('action')
        params = keyword_def.get('params', {})

        # å¤„ç†å‚æ•°ä¸­çš„å˜é‡å¼•ç”¨
        processed_params = self._process_variables(params)

        # æ‰§è¡Œå…³é”®å­—
        result = self.registry.execute(action, processed_params)

        # ä¿å­˜ç»“æœåˆ°ä¸Šä¸‹æ–‡
        if 'save_as' in keyword_def:
            self.context[keyword_def['save_as']] = result

        return result

    def _process_variables(self, params: Dict) -> Dict:
        """å¤„ç†å˜é‡å¼•ç”¨"""
        processed = {}

        for key, value in params.items():
            if isinstance(value, str) and value.startswith('${') and value.endswith('}'):
                var_name = value[2:-1]
                processed[key] = self.context.get(var_name, value)
            else:
                processed[key] = value

        return processed
        '''

### 11.3 æ¡†æ¶å¼€å‘æœ€ä½³å®è·µ

#### 11.3.1 ä»£ç ç»„ç»‡åŸåˆ™

```python
class FrameworkBestPractices:
    """æ¡†æ¶å¼€å‘æœ€ä½³å®è·µ"""

    def code_organization_principles(self) -> Dict[str, str]:
        """ä»£ç ç»„ç»‡åŸåˆ™"""
        return {
            "å•ä¸€èŒè´£": "æ¯ä¸ªæ¨¡å—åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½",
            "ä¾èµ–å€’ç½®": "é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½ä¾èµ–æŠ½è±¡",
            "å¼€é—­åŸåˆ™": "å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­",
            "æ¥å£éš”ç¦»": "å®¢æˆ·ç«¯ä¸åº”ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£",
            "æœ€å°çŸ¥è¯†": "ä¸€ä¸ªå¯¹è±¡åº”è¯¥å¯¹å…¶ä»–å¯¹è±¡æœ‰æœ€å°‘çš„äº†è§£"
        }

    def naming_conventions(self) -> Dict[str, List[str]]:
        """å‘½åè§„èŒƒ"""
        return {
            "ç±»å": [
                "ä½¿ç”¨PascalCaseï¼šTestExecutor, ConfigManager",
                "åè¯æˆ–åè¯çŸ­è¯­ï¼šUserManager, DatabaseHelper",
                "é¿å…ç¼©å†™ï¼šä½¿ç”¨Configurationè€Œä¸æ˜¯Config"
            ],
            "æ–¹æ³•å": [
                "ä½¿ç”¨snake_caseï¼šexecute_test_case, load_config",
                "åŠ¨è¯å¼€å¤´ï¼šget_user, set_config, validate_data",
                "å¸ƒå°”æ–¹æ³•ç”¨is/haså¼€å¤´ï¼šis_valid, has_permission"
            ],
            "å˜é‡å": [
                "ä½¿ç”¨snake_caseï¼štest_result, config_data",
                "æè¿°æ€§åç§°ï¼šuser_countè€Œä¸æ˜¯count",
                "å¸¸é‡ä½¿ç”¨UPPER_CASEï¼šMAX_RETRY_TIMES"
            ],
            "æ–‡ä»¶å": [
                "ä½¿ç”¨snake_caseï¼štest_executor.py, config_manager.py",
                "æ¨¡å—åç®€çŸ­ä¸”æè¿°æ€§ï¼šcore, utils, plugins",
                "é¿å…ä¸æ ‡å‡†åº“å†²çªï¼šä¸è¦ä½¿ç”¨test.py"
            ]
        }

    def error_handling_patterns(self) -> str:
        """é”™è¯¯å¤„ç†æ¨¡å¼"""
        return '''
# 1. è‡ªå®šä¹‰å¼‚å¸¸å±‚æ¬¡ç»“æ„
class FrameworkError(Exception):
    """æ¡†æ¶åŸºç¡€å¼‚å¸¸"""
    pass

class ConfigurationError(FrameworkError):
    """é…ç½®é”™è¯¯"""
    pass

class TestExecutionError(FrameworkError):
    """æµ‹è¯•æ‰§è¡Œé”™è¯¯"""
    pass

class KeywordError(FrameworkError):
    """å…³é”®å­—é”™è¯¯"""
    pass

# 2. é”™è¯¯ä¸Šä¸‹æ–‡ç®¡ç†
class ErrorContext:
    def __init__(self, operation: str):
        self.operation = operation
        self.start_time = time.time()

    def __enter__(self):
        logger.debug(f"å¼€å§‹æ“ä½œ: {self.operation}")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = time.time() - self.start_time

        if exc_type is None:
            logger.debug(f"æ“ä½œå®Œæˆ: {self.operation}, è€—æ—¶: {duration:.2f}s")
        else:
            logger.error(f"æ“ä½œå¤±è´¥: {self.operation}, é”™è¯¯: {exc_val}, è€—æ—¶: {duration:.2f}s")

        return False  # ä¸æŠ‘åˆ¶å¼‚å¸¸

# 3. ä½¿ç”¨ç¤ºä¾‹
def execute_test_case(self, test_case: Dict) -> TestResult:
    with ErrorContext(f"æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹: {test_case.get('case_name')}"):
        try:
            # æ‰§è¡Œæµ‹è¯•é€»è¾‘
            result = self._do_execute(test_case)
            return result
        except KeyError as e:
            raise ConfigurationError(f"ç¼ºå°‘å¿…éœ€çš„é…ç½®é¡¹: {e}")
        except requests.RequestException as e:
            raise TestExecutionError(f"ç½‘ç»œè¯·æ±‚å¤±è´¥: {e}")
        except Exception as e:
            raise TestExecutionError(f"æœªçŸ¥é”™è¯¯: {e}")
        '''

#### 11.3.2 æµ‹è¯•é©±åŠ¨å¼€å‘

```python
class TDDForFramework:
    """æ¡†æ¶çš„æµ‹è¯•é©±åŠ¨å¼€å‘"""

    def unit_test_structure(self) -> str:
        """å•å…ƒæµ‹è¯•ç»“æ„"""
        return '''
# tests/unit/test_config_manager.py
import pytest
from unittest.mock import patch, mock_open
from my_framework.core.config import ConfigManager, ConfigurationError

class TestConfigManager:
    """é…ç½®ç®¡ç†å™¨æµ‹è¯•"""

    def setup_method(self):
        """æ¯ä¸ªæµ‹è¯•æ–¹æ³•å‰çš„å‡†å¤‡"""
        self.config_manager = ConfigManager()

    def test_load_valid_config(self):
        """æµ‹è¯•åŠ è½½æœ‰æ•ˆé…ç½®"""
        config_data = """
        api:
          base_url: "https://api.example.com"
          timeout: 30
        web:
          browser: "chromium"
          headless: true
        """

        with patch("builtins.open", mock_open(read_data=config_data)):
            config = self.config_manager.load("config.yaml")

            assert config.api.base_url == "https://api.example.com"
            assert config.api.timeout == 30
            assert config.web.browser == "chromium"
            assert config.web.headless is True

    def test_load_invalid_config_raises_error(self):
        """æµ‹è¯•åŠ è½½æ— æ•ˆé…ç½®æŠ›å‡ºå¼‚å¸¸"""
        invalid_config = "invalid: yaml: content:"

        with patch("builtins.open", mock_open(read_data=invalid_config)):
            with pytest.raises(ConfigurationError):
                self.config_manager.load("invalid_config.yaml")

    def test_missing_config_file_creates_default(self):
        """æµ‹è¯•ç¼ºå°‘é…ç½®æ–‡ä»¶æ—¶åˆ›å»ºé»˜è®¤é…ç½®"""
        with patch("os.path.exists", return_value=False):
            config = self.config_manager.load("missing_config.yaml")

            assert config.api.base_url == "http://localhost:8080"
            assert config.web.browser == "chromium"

    @pytest.mark.parametrize("base_url,expected_valid", [
        ("https://api.example.com", True),
        ("http://localhost:8080", True),
        ("", False),
        (None, False),
        ("invalid-url", False)
    ])
    def test_validate_base_url(self, base_url, expected_valid):
        """å‚æ•°åŒ–æµ‹è¯•URLéªŒè¯"""
        config = self.config_manager._create_default_config()
        config.api.base_url = base_url

        errors = self.config_manager.validate(config)
        is_valid = len(errors) == 0

        assert is_valid == expected_valid
        '''

    def integration_test_example(self) -> str:
        """é›†æˆæµ‹è¯•ç¤ºä¾‹"""
        return '''
# tests/integration/test_framework_integration.py
import pytest
import tempfile
import os
from pathlib import Path
from my_framework import TestFramework

class TestFrameworkIntegration:
    """æ¡†æ¶é›†æˆæµ‹è¯•"""

    def setup_method(self):
        """åˆ›å»ºä¸´æ—¶æµ‹è¯•ç¯å¢ƒ"""
        self.temp_dir = tempfile.mkdtemp()
        self.config_file = Path(self.temp_dir) / "config.yaml"
        self.test_file = Path(self.temp_dir) / "test_cases.yaml"

        # åˆ›å»ºæµ‹è¯•é…ç½®
        config_content = """
        api:
          base_url: "https://httpbin.org"
          timeout: 10
        logging:
          level: "DEBUG"
        """
        self.config_file.write_text(config_content)

        # åˆ›å»ºæµ‹è¯•ç”¨ä¾‹
        test_content = """
        test_info:
          title: "é›†æˆæµ‹è¯•ç”¨ä¾‹"
          description: "æµ‹è¯•æ¡†æ¶é›†æˆåŠŸèƒ½"

        test_cases:
          - case_name: "æµ‹è¯•GETè¯·æ±‚"
            steps:
              - action: "send_get_request"
                params:
                  url: "/get"
              - action: "assert_status_code"
                params:
                  expected: 200
        """
        self.test_file.write_text(test_content)

    def teardown_method(self):
        """æ¸…ç†ä¸´æ—¶ç¯å¢ƒ"""
        import shutil
        shutil.rmtree(self.temp_dir)

    def test_end_to_end_execution(self):
        """ç«¯åˆ°ç«¯æ‰§è¡Œæµ‹è¯•"""
        framework = TestFramework(config_path=str(self.config_file))
        results = framework.execute_test_file(str(self.test_file))

        assert len(results) == 1
        assert results[0].status == "PASSED"
        assert results[0].case_name == "æµ‹è¯•GETè¯·æ±‚"

    def test_parallel_execution(self):
        """å¹¶å‘æ‰§è¡Œæµ‹è¯•"""
        # åˆ›å»ºå¤šä¸ªæµ‹è¯•ç”¨ä¾‹
        test_content = """
        test_info:
          title: "å¹¶å‘æµ‹è¯•ç”¨ä¾‹"

        test_cases:
        """

        for i in range(5):
            test_content += f"""
          - case_name: "å¹¶å‘æµ‹è¯•_{i}"
            steps:
              - action: "send_get_request"
                params:
                  url: "/delay/1"
              - action: "assert_status_code"
                params:
                  expected: 200
            """

        self.test_file.write_text(test_content)

        # é…ç½®å¹¶å‘æ‰§è¡Œ
        config_content = """
        api:
          base_url: "https://httpbin.org"
        execution:
          parallel: true
          max_workers: 3
        """
        self.config_file.write_text(config_content)

        framework = TestFramework(config_path=str(self.config_file))

        import time
        start_time = time.time()
        results = framework.execute_test_file(str(self.test_file))
        execution_time = time.time() - start_time

        # å¹¶å‘æ‰§è¡Œåº”è¯¥æ¯”ä¸²è¡Œæ‰§è¡Œå¿«
        assert len(results) == 5
        assert all(r.status == "PASSED" for r in results)
        assert execution_time < 4  # 5ä¸ª1ç§’çš„è¯·æ±‚ï¼Œå¹¶å‘æ‰§è¡Œåº”è¯¥åœ¨4ç§’å†…å®Œæˆ
        '''

#### 11.3.3 æ–‡æ¡£é©±åŠ¨å¼€å‘

```python
class DocumentationDrivenDevelopment:
    """æ–‡æ¡£é©±åŠ¨å¼€å‘"""

    def api_documentation_template(self) -> str:
        """APIæ–‡æ¡£æ¨¡æ¿"""
        return '''
# API å‚è€ƒæ–‡æ¡£

## æ ¸å¿ƒç±»

### TestFramework

ä¸»è¦çš„æ¡†æ¶å…¥å£ç±»ï¼Œæä¾›æµ‹è¯•æ‰§è¡Œå’Œç®¡ç†åŠŸèƒ½ã€‚

#### æ„é€ å‡½æ•°

```python
TestFramework(config_path: str = "config.yaml")
````

**å‚æ•°ï¼š**

- `config_path` (str): é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œé»˜è®¤ä¸º "config.yaml"

**ç¤ºä¾‹ï¼š**

```python
framework = TestFramework("my_config.yaml")
```

#### æ–¹æ³•

##### execute_test_file

æ‰§è¡ŒæŒ‡å®šçš„æµ‹è¯•æ–‡ä»¶ã€‚

```python
execute_test_file(file_path: str, filters: Dict[str, Any] = None) -> List[TestResult]
```

**å‚æ•°ï¼š**

- `file_path` (str): æµ‹è¯•æ–‡ä»¶è·¯å¾„
- `filters` (Dict[str, Any], å¯é€‰): ç”¨ä¾‹è¿‡æ»¤æ¡ä»¶

**è¿”å›ï¼š**

- `List[TestResult]`: æµ‹è¯•ç»“æœåˆ—è¡¨

**å¼‚å¸¸ï¼š**

- `FileNotFoundError`: æµ‹è¯•æ–‡ä»¶ä¸å­˜åœ¨
- `ConfigurationError`: é…ç½®é”™è¯¯
- `TestExecutionError`: æµ‹è¯•æ‰§è¡Œé”™è¯¯

**ç¤ºä¾‹ï¼š**

```python
# æ‰§è¡Œæ‰€æœ‰ç”¨ä¾‹
results = framework.execute_test_file("tests/api_tests.yaml")

# æ‰§è¡ŒæŒ‡å®šæ ‡ç­¾çš„ç”¨ä¾‹
results = framework.execute_test_file(
    "tests/api_tests.yaml",
    filters={"tags": ["smoke"]}
)
```

##### execute_test_cases

ç›´æ¥æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹åˆ—è¡¨ã€‚

```python
execute_test_cases(test_cases: List[Dict[str, Any]]) -> List[TestResult]
```

**å‚æ•°ï¼š**

- `test_cases` (List[Dict[str, Any]]): æµ‹è¯•ç”¨ä¾‹åˆ—è¡¨

**è¿”å›ï¼š**

- `List[TestResult]`: æµ‹è¯•ç»“æœåˆ—è¡¨

**ç¤ºä¾‹ï¼š**

```python
test_cases = [
    {
        "case_name": "æµ‹è¯•ç™»å½•",
        "steps": [
            {"action": "send_post_request", "params": {"url": "/login", "data": {"username": "admin"}}}
        ]
    }
]
results = framework.execute_test_cases(test_cases)
```

### TestResult

æµ‹è¯•ç»“æœç±»ï¼ŒåŒ…å«æµ‹è¯•æ‰§è¡Œçš„è¯¦ç»†ä¿¡æ¯ã€‚

#### å±æ€§

- `case_name` (str): ç”¨ä¾‹åç§°
- `status` (TestStatus): æ‰§è¡ŒçŠ¶æ€ (PASSED/FAILED/SKIPPED)
- `start_time` (datetime): å¼€å§‹æ—¶é—´
- `end_time` (datetime): ç»“æŸæ—¶é—´
- `duration` (float): æ‰§è¡Œæ—¶é•¿ï¼ˆç§’ï¼‰
- `error_message` (str): é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
- `steps` (List[Dict]): æ‰§è¡Œæ­¥éª¤è¯¦æƒ…
- `attachments` (List[str]): é™„ä»¶è·¯å¾„åˆ—è¡¨

#### æ–¹æ³•

##### to_dict

å°†ç»“æœè½¬æ¢ä¸ºå­—å…¸æ ¼å¼ã€‚

```python
to_dict() -> Dict[str, Any]
```

**è¿”å›ï¼š**

- `Dict[str, Any]`: ç»“æœå­—å…¸

**ç¤ºä¾‹ï¼š**

```python
result_dict = test_result.to_dict()
print(json.dumps(result_dict, indent=2))
```

        '''

    def user_guide_template(self) -> str:
        """ç”¨æˆ·æŒ‡å—æ¨¡æ¿"""
        return '''

# ç”¨æˆ·æŒ‡å—

## å¿«é€Ÿå¼€å§‹

### å®‰è£…

```bash
pip install my-test-framework
```

### åŸºç¡€é…ç½®

åˆ›å»ºé…ç½®æ–‡ä»¶ `config.yaml`ï¼š

```yaml
api:
  base_url: "https://api.example.com"
  timeout: 30
  headers:
    Content-Type: "application/json"

web:
  browser: "chromium"
  headless: false
  viewport:
    width: 1920
    height: 1080

logging:
  level: "INFO"
  file: "test.log"

execution:
  parallel: false
  max_workers: 4
```

### ç¼–å†™ç¬¬ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹

åˆ›å»ºæµ‹è¯•æ–‡ä»¶ `my_first_test.yaml`ï¼š

```yaml
test_info:
  title: "æˆ‘çš„ç¬¬ä¸€ä¸ªæµ‹è¯•"
  description: "å­¦ä¹ å¦‚ä½•ä½¿ç”¨æµ‹è¯•æ¡†æ¶"
  tags: ["tutorial", "basic"]

test_cases:
  - case_name: "æµ‹è¯•APIå“åº”"
    description: "éªŒè¯APIè¿”å›æ­£ç¡®çš„çŠ¶æ€ç "
    steps:
      - action: "send_get_request"
        params:
          url: "/users/1"
        save_as: "user_response"

      - action: "assert_status_code"
        params:
          response: "${user_response}"
          expected: 200

      - action: "assert_json_path"
        params:
          response: "${user_response}"
          path: "$.id"
          expected: 1
```

### æ‰§è¡Œæµ‹è¯•

```python
from my_framework import TestFramework

# åˆ›å»ºæ¡†æ¶å®ä¾‹
framework = TestFramework("config.yaml")

# æ‰§è¡Œæµ‹è¯•
results = framework.execute_test_file("my_first_test.yaml")

# æŸ¥çœ‹ç»“æœ
for result in results:
    print(f"ç”¨ä¾‹: {result.case_name}")
    print(f"çŠ¶æ€: {result.status}")
    if result.status == "FAILED":
        print(f"é”™è¯¯: {result.error_message}")
```

## é«˜çº§åŠŸèƒ½

### æ•°æ®é©±åŠ¨æµ‹è¯•

ä½¿ç”¨å¤–éƒ¨æ•°æ®æ–‡ä»¶é©±åŠ¨æµ‹è¯•ï¼š

```yaml
test_info:
  title: "æ•°æ®é©±åŠ¨æµ‹è¯•ç¤ºä¾‹"

test_cases:
  - case_name: "ç”¨æˆ·ç™»å½•æµ‹è¯•"
    data_source: "users.csv"
    template:
      steps:
        - action: "send_post_request"
          params:
            url: "/login"
            data:
              username: "${username}"
              password: "${password}"

        - action: "assert_status_code"
          params:
            expected: "${expected_status}"
```

### è‡ªå®šä¹‰å…³é”®å­—

```python
from my_framework.keywords import keyword

@keyword("custom_login")
def custom_login(username: str, password: str) -> Dict:
    """è‡ªå®šä¹‰ç™»å½•å…³é”®å­—"""
    # å®ç°ç™»å½•é€»è¾‘
    response = requests.post("/api/login", json={
        "username": username,
        "password": password
    })

    if response.status_code == 200:
        return response.json()
    else:
        raise Exception(f"ç™»å½•å¤±è´¥: {response.text}")

# åœ¨æµ‹è¯•ç”¨ä¾‹ä¸­ä½¿ç”¨
# - action: "custom_login"
#   params:
#     username: "admin"
#     password: "123456"
```

### ç¯å¢ƒå˜é‡æ”¯æŒ

åœ¨é…ç½®å’Œæµ‹è¯•ç”¨ä¾‹ä¸­ä½¿ç”¨ç¯å¢ƒå˜é‡ï¼š

```yaml
api:
  base_url: "${API_BASE_URL}"
  auth_token: "${API_TOKEN}"

test_cases:
  - case_name: "ç¯å¢ƒç›¸å…³æµ‹è¯•"
    steps:
      - action: "send_get_request"
        params:
          url: "/api/data"
          headers:
            Authorization: "Bearer ${API_TOKEN}"
```

## æœ€ä½³å®è·µ

### ç”¨ä¾‹ç»„ç»‡

1. **æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡**ï¼šå°†ç›¸å…³çš„æµ‹è¯•ç”¨ä¾‹æ”¾åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­
2. **ä½¿ç”¨æè¿°æ€§åç§°**ï¼šç”¨ä¾‹åç§°åº”è¯¥æ¸…æ¥šåœ°æè¿°æµ‹è¯•ç›®çš„
3. **æ·»åŠ æ ‡ç­¾**ï¼šä½¿ç”¨æ ‡ç­¾å¯¹ç”¨ä¾‹è¿›è¡Œåˆ†ç±»ï¼Œä¾¿äºç­›é€‰æ‰§è¡Œ

### æ•°æ®ç®¡ç†

1. **åˆ†ç¦»æµ‹è¯•æ•°æ®**ï¼šå°†æµ‹è¯•æ•°æ®ä¸æµ‹è¯•é€»è¾‘åˆ†ç¦»
2. **ä½¿ç”¨å˜é‡**ï¼šé¿å…ç¡¬ç¼–ç ï¼Œä½¿ç”¨å˜é‡æé«˜å¯ç»´æŠ¤æ€§
3. **ç¯å¢ƒéš”ç¦»**ï¼šä¸åŒç¯å¢ƒä½¿ç”¨ä¸åŒçš„æµ‹è¯•æ•°æ®

### é”™è¯¯å¤„ç†

1. **è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯**ï¼šæä¾›è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ä¿¡æ¯å¸®åŠ©è°ƒè¯•
2. **æˆªå›¾å’Œæ—¥å¿—**ï¼šWeb æµ‹è¯•å¤±è´¥æ—¶è‡ªåŠ¨æˆªå›¾
3. **é‡è¯•æœºåˆ¶**ï¼šå¯¹äºä¸ç¨³å®šçš„æµ‹è¯•ï¼Œé…ç½®åˆç†çš„é‡è¯•ç­–ç•¥
   '''

---

## 12. æ¡†æ¶æ¼”è¿›ä¸ç»´æŠ¤

### 12.1 ç‰ˆæœ¬ç®¡ç†ç­–ç•¥

````python
class FrameworkVersioning:
    """æ¡†æ¶ç‰ˆæœ¬ç®¡ç†"""

    def semantic_versioning_guide(self) -> Dict[str, str]:
        """è¯­ä¹‰åŒ–ç‰ˆæœ¬æŒ‡å—"""
        return {
            "ä¸»ç‰ˆæœ¬å· (MAJOR)": "ä¸å…¼å®¹çš„APIä¿®æ”¹",
            "æ¬¡ç‰ˆæœ¬å· (MINOR)": "å‘ä¸‹å…¼å®¹çš„åŠŸèƒ½æ€§æ–°å¢",
            "ä¿®è®¢å· (PATCH)": "å‘ä¸‹å…¼å®¹çš„é—®é¢˜ä¿®æ­£",
            "é¢„å‘å¸ƒç‰ˆæœ¬": "alpha, beta, rcç­‰æ ‡è¯†",
            "æ„å»ºå…ƒæ•°æ®": "æ„å»ºä¿¡æ¯ï¼Œä¸å½±å“ç‰ˆæœ¬ä¼˜å…ˆçº§"
        }

    def version_compatibility_matrix(self) -> str:
        """ç‰ˆæœ¬å…¼å®¹æ€§çŸ©é˜µ"""
        return '''
| æ¡†æ¶ç‰ˆæœ¬ | Pythonç‰ˆæœ¬ | ä¸»è¦ç‰¹æ€§ | å…¼å®¹æ€§è¯´æ˜ |
|---------|-----------|---------|-----------|
| 1.0.x   | 3.7+      | åŸºç¡€åŠŸèƒ½ | ç¨³å®šç‰ˆæœ¬ |
| 1.1.x   | 3.7+      | æ’ä»¶ç³»ç»Ÿ | å‘ä¸‹å…¼å®¹ |
| 1.2.x   | 3.8+      | å¼‚æ­¥æ”¯æŒ | å‘ä¸‹å…¼å®¹ |
| 2.0.x   | 3.8+      | æ¶æ„é‡æ„ | ç ´åæ€§å˜æ›´ |
| 2.1.x   | 3.9+      | äº‘åŸç”Ÿæ”¯æŒ | å‘ä¸‹å…¼å®¹ |

### å‡çº§æŒ‡å—

#### ä» 1.x å‡çº§åˆ° 2.0

**ç ´åæ€§å˜æ›´ï¼š**
1. é…ç½®æ–‡ä»¶æ ¼å¼å˜æ›´
2. APIæ¥å£é‡å‘½å
3. æ’ä»¶æ¥å£è°ƒæ•´

**è¿ç§»æ­¥éª¤ï¼š**
1. å¤‡ä»½ç°æœ‰é…ç½®å’Œæµ‹è¯•ç”¨ä¾‹
2. æ›´æ–°é…ç½®æ–‡ä»¶æ ¼å¼
3. ä¿®æ”¹è‡ªå®šä¹‰æ’ä»¶æ¥å£
4. è¿è¡Œå…¼å®¹æ€§æ£€æŸ¥å·¥å…·
5. é€æ­¥éªŒè¯æµ‹è¯•ç”¨ä¾‹
        '''

    def deprecation_policy(self) -> Dict[str, str]:
        """åºŸå¼ƒç­–ç•¥"""
        return {
            "é€šçŸ¥æœŸ": "è‡³å°‘æå‰ä¸€ä¸ªä¸»ç‰ˆæœ¬é€šçŸ¥åºŸå¼ƒ",
            "æ”¯æŒæœŸ": "åºŸå¼ƒåŠŸèƒ½åœ¨ä¸‹ä¸€ä¸ªä¸»ç‰ˆæœ¬ä¸­ä»å¯ç”¨",
            "ç§»é™¤æœŸ": "åœ¨ç¬¬äºŒä¸ªä¸»ç‰ˆæœ¬ä¸­å®Œå…¨ç§»é™¤",
            "æ–‡æ¡£æ ‡è®°": "åœ¨æ–‡æ¡£ä¸­æ˜ç¡®æ ‡è®°ä¸ºåºŸå¼ƒ",
            "è­¦å‘Šä¿¡æ¯": "è¿è¡Œæ—¶è¾“å‡ºåºŸå¼ƒè­¦å‘Š"
        }

class FrameworkMaintenance:
    """æ¡†æ¶ç»´æŠ¤æŒ‡å—"""

    def maintenance_checklist(self) -> List[str]:
        """ç»´æŠ¤æ£€æŸ¥æ¸…å•"""
        return [
            "ğŸ” ä»£ç è´¨é‡æ£€æŸ¥",
            "  - è¿è¡Œé™æ€ä»£ç åˆ†æå·¥å…·",
            "  - æ£€æŸ¥ä»£ç è¦†ç›–ç‡",
            "  - å®¡æŸ¥ä»£ç å¤æ‚åº¦",
            "",
            "ğŸ§ª æµ‹è¯•éªŒè¯",
            "  - æ‰§è¡Œå®Œæ•´çš„æµ‹è¯•å¥—ä»¶",
            "  - éªŒè¯å‘åå…¼å®¹æ€§",
            "  - æ€§èƒ½å›å½’æµ‹è¯•",
            "",
            "ğŸ“š æ–‡æ¡£æ›´æ–°",
            "  - æ›´æ–°APIæ–‡æ¡£",
            "  - æ£€æŸ¥ç¤ºä¾‹ä»£ç ",
            "  - æ›´æ–°å˜æ›´æ—¥å¿—",
            "",
            "ğŸ”’ å®‰å…¨æ£€æŸ¥",
            "  - æ‰«æä¾èµ–æ¼æ´",
            "  - æ£€æŸ¥æ•æ„Ÿä¿¡æ¯æ³„éœ²",
            "  - éªŒè¯æƒé™æ§åˆ¶",
            "",
            "ğŸ“¦ ä¾èµ–ç®¡ç†",
            "  - æ›´æ–°ä¾èµ–ç‰ˆæœ¬",
            "  - æ£€æŸ¥è®¸å¯è¯å…¼å®¹æ€§",
            "  - ç§»é™¤æœªä½¿ç”¨çš„ä¾èµ–"
        ]

    def performance_monitoring(self) -> str:
        """æ€§èƒ½ç›‘æ§å®ç°"""
        return '''
class FrameworkPerformanceMonitor:
    """æ¡†æ¶æ€§èƒ½ç›‘æ§"""

    def __init__(self):
        self.metrics = {}
        self.thresholds = {
            'test_execution_time': 300,  # 5åˆ†é’Ÿ
            'memory_usage_mb': 1024,     # 1GB
            'cpu_usage_percent': 80      # 80%
        }

    def monitor_test_execution(self, func):
        """ç›‘æ§æµ‹è¯•æ‰§è¡Œæ€§èƒ½"""
        def wrapper(*args, **kwargs):
            start_time = time.time()
            start_memory = self._get_memory_usage()

            try:
                result = func(*args, **kwargs)

                # è®°å½•æ€§èƒ½æŒ‡æ ‡
                execution_time = time.time() - start_time
                memory_used = self._get_memory_usage() - start_memory

                self._record_metrics({
                    'execution_time': execution_time,
                    'memory_usage': memory_used,
                    'timestamp': datetime.now().isoformat()
                })

                # æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
                self._check_performance_thresholds(execution_time, memory_used)

                return result

            except Exception as e:
                logger.error(f"æµ‹è¯•æ‰§è¡Œå¼‚å¸¸: {e}")
                raise

        return wrapper

    def _record_metrics(self, metrics: Dict):
        """è®°å½•æ€§èƒ½æŒ‡æ ‡"""
        # ä¿å­˜åˆ°æ—¶åºæ•°æ®åº“æˆ–æ–‡ä»¶
        with open('performance_metrics.jsonl', 'a') as f:
            f.write(json.dumps(metrics) + '\\n')

    def _check_performance_thresholds(self, execution_time: float, memory_usage: float):
        """æ£€æŸ¥æ€§èƒ½é˜ˆå€¼"""
        if execution_time > self.thresholds['test_execution_time']:
            logger.warning(f"æµ‹è¯•æ‰§è¡Œæ—¶é—´è¶…è¿‡é˜ˆå€¼: {execution_time:.2f}s")

        if memory_usage > self.thresholds['memory_usage_mb']:
            logger.warning(f"å†…å­˜ä½¿ç”¨è¶…è¿‡é˜ˆå€¼: {memory_usage:.2f}MB")

    def generate_performance_report(self) -> Dict:
        """ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š"""
        # åˆ†ææ€§èƒ½æ•°æ®ï¼Œç”Ÿæˆè¶‹åŠ¿æŠ¥å‘Š
        pass
        '''

### 12.2 ç¤¾åŒºå»ºè®¾ä¸è´¡çŒ®

```python
class CommunityBuilding:
    """ç¤¾åŒºå»ºè®¾æŒ‡å—"""

    def contribution_guidelines(self) -> str:
        """è´¡çŒ®æŒ‡å—"""
        return '''
# è´¡çŒ®æŒ‡å—

## å¦‚ä½•è´¡çŒ®

### æŠ¥å‘Šé—®é¢˜

1. **æœç´¢ç°æœ‰é—®é¢˜**ï¼šç¡®è®¤é—®é¢˜æœªè¢«æŠ¥å‘Š
2. **ä½¿ç”¨é—®é¢˜æ¨¡æ¿**ï¼šæä¾›è¯¦ç»†çš„é‡ç°æ­¥éª¤
3. **åŒ…å«ç¯å¢ƒä¿¡æ¯**ï¼šæ“ä½œç³»ç»Ÿã€Pythonç‰ˆæœ¬ã€æ¡†æ¶ç‰ˆæœ¬
4. **æä¾›æœ€å°é‡ç°ç¤ºä¾‹**ï¼šç®€åŒ–çš„ä»£ç ç¤ºä¾‹

### æäº¤ä»£ç 

1. **Fork é¡¹ç›®**ï¼šåˆ›å»ºä¸ªäººåˆ†æ”¯
2. **åˆ›å»ºç‰¹æ€§åˆ†æ”¯**ï¼š`git checkout -b feature/new-feature`
3. **ç¼–å†™æµ‹è¯•**ï¼šç¡®ä¿æ–°åŠŸèƒ½æœ‰æµ‹è¯•è¦†ç›–
4. **éµå¾ªä»£ç è§„èŒƒ**ï¼šä½¿ç”¨ blackã€flake8 ç­‰å·¥å…·
5. **æäº¤ Pull Request**ï¼šè¯¦ç»†æè¿°å˜æ›´å†…å®¹

### ä»£ç å®¡æŸ¥æµç¨‹

1. **è‡ªåŠ¨åŒ–æ£€æŸ¥**ï¼šCI/CD æµæ°´çº¿éªŒè¯
2. **åŒè¡Œå®¡æŸ¥**ï¼šè‡³å°‘ä¸€åç»´æŠ¤è€…å®¡æŸ¥
3. **æµ‹è¯•éªŒè¯**ï¼šç¡®ä¿æ‰€æœ‰æµ‹è¯•é€šè¿‡
4. **æ–‡æ¡£æ›´æ–°**ï¼šå¿…è¦æ—¶æ›´æ–°æ–‡æ¡£
5. **åˆå¹¶ä»£ç **ï¼šç»´æŠ¤è€…åˆå¹¶åˆ°ä¸»åˆ†æ”¯

## å¼€å‘ç¯å¢ƒè®¾ç½®

```bash
# å…‹éš†é¡¹ç›®
git clone https://github.com/your-org/test-framework.git
cd test-framework

# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\\Scripts\\activate  # Windows

# å®‰è£…å¼€å‘ä¾èµ–
pip install -e ".[dev]"

# å®‰è£… pre-commit é’©å­
pre-commit install

# è¿è¡Œæµ‹è¯•
pytest tests/

# ä»£ç æ ¼å¼åŒ–
black src/ tests/
isort src/ tests/

# é™æ€åˆ†æ
flake8 src/ tests/
mypy src/
````

## å‘å¸ƒæµç¨‹

1. **æ›´æ–°ç‰ˆæœ¬å·**ï¼šä¿®æ”¹ `__version__.py`
2. **æ›´æ–°å˜æ›´æ—¥å¿—**ï¼šè®°å½•æ–°åŠŸèƒ½å’Œä¿®å¤
3. **åˆ›å»ºå‘å¸ƒæ ‡ç­¾**ï¼š`git tag v1.2.0`
4. **æ„å»ºåˆ†å‘åŒ…**ï¼š`python setup.py sdist bdist_wheel`
5. **ä¸Šä¼ åˆ° PyPI**ï¼š`twine upload dist/*`
6. **å‘å¸ƒ GitHub Release**ï¼šåŒ…å«å˜æ›´è¯´æ˜
   '''

   def documentation_standards(self) -> Dict[str, str]:
   """æ–‡æ¡£æ ‡å‡†"""
   return {
   "API æ–‡æ¡£": "ä½¿ç”¨ Sphinx è‡ªåŠ¨ç”Ÿæˆï¼ŒåŒ…å«ç±»å‹æ³¨è§£",
   "ç”¨æˆ·æŒ‡å—": "é¢å‘æœ€ç»ˆç”¨æˆ·ï¼ŒåŒ…å«å®Œæ•´ç¤ºä¾‹",
   "å¼€å‘è€…æŒ‡å—": "é¢å‘è´¡çŒ®è€…ï¼ŒåŒ…å«æ¶æ„è¯´æ˜",
   "å˜æ›´æ—¥å¿—": "è®°å½•æ¯ä¸ªç‰ˆæœ¬çš„å˜æ›´å†…å®¹",
   "FAQ": "å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ",
   "ç¤ºä¾‹ä»£ç ": "å¯è¿è¡Œçš„å®Œæ•´ç¤ºä¾‹"
   }

   def community_metrics(self) -> List[str]:
   """ç¤¾åŒºæŒ‡æ ‡"""
   return [
   "ğŸ“Š é¡¹ç›®ç»Ÿè®¡",
   " - GitHub Stars æ•°é‡",
   " - Fork æ•°é‡",
   " - è´¡çŒ®è€…æ•°é‡",
   " - æäº¤é¢‘ç‡",
   "",
   "ğŸ› é—®é¢˜è·Ÿè¸ª",
   " - å¼€æ”¾é—®é¢˜æ•°é‡",
   " - é—®é¢˜è§£å†³æ—¶é—´",
   " - é—®é¢˜åˆ†ç±»ç»Ÿè®¡",
   "",
   "ğŸ”„ ä»£ç æ´»è·ƒåº¦",
   " - Pull Request æ•°é‡",
   " - ä»£ç å®¡æŸ¥æ—¶é—´",
   " - åˆå¹¶ç‡",
   "",
   "ğŸ“ˆ ä½¿ç”¨æƒ…å†µ",
   " - PyPI ä¸‹è½½é‡",
   " - æ–‡æ¡£è®¿é—®é‡",
   " - ç¤¾åŒºè®¨è®ºæ´»è·ƒåº¦"
   ]

````

---

## 13. å®‰å…¨ä¸åˆè§„è€ƒè™‘

### 13.1 å®‰å…¨è®¾è®¡åŸåˆ™

```python
class SecurityConsiderations:
    """å®‰å…¨è€ƒè™‘"""

    def security_principles(self) -> Dict[str, str]:
        """å®‰å…¨è®¾è®¡åŸåˆ™"""
        return {
            "æœ€å°æƒé™åŸåˆ™": "åªæˆäºˆå®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™",
            "æ·±åº¦é˜²å¾¡": "å¤šå±‚å®‰å…¨æ§åˆ¶ï¼Œé¿å…å•ç‚¹å¤±è´¥",
            "å®‰å…¨é»˜è®¤": "é»˜è®¤é…ç½®åº”è¯¥æ˜¯å®‰å…¨çš„",
            "å¤±è´¥å®‰å…¨": "ç³»ç»Ÿå¤±è´¥æ—¶åº”è¯¥ä¿æŒå®‰å…¨çŠ¶æ€",
            "å®Œæ•´æ€§ä¿æŠ¤": "ç¡®ä¿æ•°æ®å’Œä»£ç çš„å®Œæ•´æ€§",
            "å¯å®¡è®¡æ€§": "è®°å½•å®‰å…¨ç›¸å…³çš„æ“ä½œå’Œäº‹ä»¶"
        }

    def sensitive_data_handling(self) -> str:
        """æ•æ„Ÿæ•°æ®å¤„ç†"""
        return '''
class SecureDataHandler:
    """å®‰å…¨æ•°æ®å¤„ç†å™¨"""

    def __init__(self):
        self.encryption_key = self._load_encryption_key()
        self.sensitive_patterns = [
            r'password["\']?\s*[:=]\s*["\']?([^"\'\\s]+)',
            r'token["\']?\s*[:=]\s*["\']?([^"\'\\s]+)',
            r'secret["\']?\s*[:=]\s*["\']?([^"\'\\s]+)',
            r'api[_-]?key["\']?\s*[:=]\s*["\']?([^"\'\\s]+)'
        ]

    def sanitize_logs(self, log_content: str) -> str:
        """æ¸…ç†æ—¥å¿—ä¸­çš„æ•æ„Ÿä¿¡æ¯"""
        sanitized = log_content

        for pattern in self.sensitive_patterns:
            sanitized = re.sub(
                pattern,
                lambda m: m.group(0).replace(m.group(1), '***'),
                sanitized,
                flags=re.IGNORECASE
            )

        return sanitized

    def encrypt_sensitive_config(self, config_data: Dict) -> Dict:
        """åŠ å¯†æ•æ„Ÿé…ç½®"""
        from cryptography.fernet import Fernet

        cipher = Fernet(self.encryption_key)
        encrypted_config = config_data.copy()

        sensitive_keys = ['password', 'token', 'secret', 'api_key']

        def encrypt_recursive(data):
            if isinstance(data, dict):
                result = {}
                for key, value in data.items():
                    if any(sensitive_key in key.lower() for sensitive_key in sensitive_keys):
                        if isinstance(value, str):
                            result[key] = cipher.encrypt(value.encode()).decode()
                        else:
                            result[key] = value
                    else:
                        result[key] = encrypt_recursive(value)
                return result
            elif isinstance(data, list):
                return [encrypt_recursive(item) for item in data]
            else:
                return data

        return encrypt_recursive(encrypted_config)

    def validate_input(self, input_data: Any) -> bool:
        """éªŒè¯è¾“å…¥æ•°æ®"""
        # é˜²æ­¢ä»£ç æ³¨å…¥
        dangerous_patterns = [
            r'__import__',
            r'eval\s*\(',
            r'exec\s*\(',
            r'subprocess',
            r'os\.system',
            r'open\s*\('
        ]

        input_str = str(input_data)

        for pattern in dangerous_patterns:
            if re.search(pattern, input_str, re.IGNORECASE):
                logger.warning(f"æ£€æµ‹åˆ°æ½œåœ¨å±é™©è¾“å…¥: {pattern}")
                return False

        return True

    def _load_encryption_key(self) -> bytes:
        """åŠ è½½åŠ å¯†å¯†é’¥"""
        key_file = os.getenv('ENCRYPTION_KEY_FILE', '.encryption_key')

        if os.path.exists(key_file):
            with open(key_file, 'rb') as f:
                return f.read()
        else:
            # ç”Ÿæˆæ–°å¯†é’¥
            from cryptography.fernet import Fernet
            key = Fernet.generate_key()

            with open(key_file, 'wb') as f:
                f.write(key)

            os.chmod(key_file, 0o600)  # åªæœ‰æ‰€æœ‰è€…å¯è¯»å†™
            return key
        '''

    def access_control(self) -> str:
        """è®¿é—®æ§åˆ¶å®ç°"""
        return '''
class AccessController:
    """è®¿é—®æ§åˆ¶å™¨"""

    def __init__(self):
        self.permissions = {}
        self.roles = {}
        self.user_roles = {}

    def define_permission(self, permission: str, description: str):
        """å®šä¹‰æƒé™"""
        self.permissions[permission] = description

    def define_role(self, role: str, permissions: List[str]):
        """å®šä¹‰è§’è‰²"""
        # éªŒè¯æƒé™æ˜¯å¦å­˜åœ¨
        for perm in permissions:
            if perm not in self.permissions:
                raise ValueError(f"æœªçŸ¥æƒé™: {perm}")

        self.roles[role] = permissions

    def assign_role(self, user: str, role: str):
        """åˆ†é…è§’è‰²"""
        if role not in self.roles:
            raise ValueError(f"æœªçŸ¥è§’è‰²: {role}")

        if user not in self.user_roles:
            self.user_roles[user] = []

        self.user_roles[user].append(role)

    def check_permission(self, user: str, permission: str) -> bool:
        """æ£€æŸ¥æƒé™"""
        user_permissions = set()

        # è·å–ç”¨æˆ·çš„æ‰€æœ‰æƒé™
        for role in self.user_roles.get(user, []):
            user_permissions.update(self.roles.get(role, []))

        return permission in user_permissions

    def require_permission(self, permission: str):
        """æƒé™è£…é¥°å™¨"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                # ä»ä¸Šä¸‹æ–‡è·å–å½“å‰ç”¨æˆ·
                current_user = self._get_current_user()

                if not self.check_permission(current_user, permission):
                    raise PermissionError(f"ç”¨æˆ· {current_user} ç¼ºå°‘æƒé™: {permission}")

                return func(*args, **kwargs)
            return wrapper
        return decorator

    def _get_current_user(self) -> str:
        """è·å–å½“å‰ç”¨æˆ·"""
        # ä»ç¯å¢ƒå˜é‡ã€JWT token æˆ–å…¶ä»–æ–¹å¼è·å–
        return os.getenv('CURRENT_USER', 'anonymous')

# ä½¿ç”¨ç¤ºä¾‹
access_controller = AccessController()

# å®šä¹‰æƒé™
access_controller.define_permission('execute_tests', 'æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹')
access_controller.define_permission('manage_config', 'ç®¡ç†é…ç½®')
access_controller.define_permission('view_reports', 'æŸ¥çœ‹æŠ¥å‘Š')

# å®šä¹‰è§’è‰²
access_controller.define_role('tester', ['execute_tests', 'view_reports'])
access_controller.define_role('admin', ['execute_tests', 'manage_config', 'view_reports'])

# åˆ†é…è§’è‰²
access_controller.assign_role('alice', 'tester')
access_controller.assign_role('bob', 'admin')

# ä½¿ç”¨æƒé™æ§åˆ¶
@access_controller.require_permission('execute_tests')
def execute_test_suite():
    # æ‰§è¡Œæµ‹è¯•é€»è¾‘
    pass
        '''

### 13.2 åˆè§„æ€§è¦æ±‚

```python
class ComplianceFramework:
    """åˆè§„æ€§æ¡†æ¶"""

    def gdpr_compliance(self) -> Dict[str, str]:
        """GDPR åˆè§„è¦æ±‚"""
        return {
            "æ•°æ®æœ€å°åŒ–": "åªæ”¶é›†å’Œå¤„ç†å¿…è¦çš„ä¸ªäººæ•°æ®",
            "ç›®çš„é™åˆ¶": "æ˜ç¡®æ•°æ®å¤„ç†çš„ç›®çš„å’ŒèŒƒå›´",
            "å­˜å‚¨é™åˆ¶": "ä¸è¶…è¿‡å¿…è¦æœŸé™å­˜å‚¨ä¸ªäººæ•°æ®",
            "æ•°æ®å‡†ç¡®æ€§": "ç¡®ä¿ä¸ªäººæ•°æ®çš„å‡†ç¡®æ€§å’ŒåŠæ—¶æ›´æ–°",
            "å®Œæ•´æ€§å’Œä¿å¯†æ€§": "é‡‡å–é€‚å½“çš„å®‰å…¨æªæ–½ä¿æŠ¤æ•°æ®",
            "å¯é—®è´£æ€§": "èƒ½å¤Ÿè¯æ˜ç¬¦åˆGDPRè¦æ±‚"
        }

    def audit_logging(self) -> str:
        """å®¡è®¡æ—¥å¿—å®ç°"""
        return '''
class AuditLogger:
    """å®¡è®¡æ—¥å¿—è®°å½•å™¨"""

    def __init__(self):
        self.audit_log_file = "audit.log"
        self.logger = self._setup_audit_logger()

    def _setup_audit_logger(self):
        """è®¾ç½®å®¡è®¡æ—¥å¿—è®°å½•å™¨"""
        audit_logger = logging.getLogger('audit')
        audit_logger.setLevel(logging.INFO)

        # æ–‡ä»¶å¤„ç†å™¨
        file_handler = logging.FileHandler(self.audit_log_file)
        file_handler.setLevel(logging.INFO)

        # æ ¼å¼åŒ–å™¨
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(formatter)

        audit_logger.addHandler(file_handler)
        return audit_logger

    def log_user_action(self, user: str, action: str, resource: str, result: str):
        """è®°å½•ç”¨æˆ·æ“ä½œ"""
        audit_entry = {
            'timestamp': datetime.now().isoformat(),
            'user': user,
            'action': action,
            'resource': resource,
            'result': result,
            'ip_address': self._get_client_ip(),
            'user_agent': self._get_user_agent()
        }

        self.logger.info(json.dumps(audit_entry))

    def log_system_event(self, event_type: str, description: str, severity: str = 'INFO'):
        """è®°å½•ç³»ç»Ÿäº‹ä»¶"""
        system_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_type': event_type,
            'description': description,
            'severity': severity,
            'system_info': self._get_system_info()
        }

        self.logger.info(json.dumps(system_entry))

    def log_data_access(self, user: str, data_type: str, operation: str, record_count: int):
        """è®°å½•æ•°æ®è®¿é—®"""
        data_entry = {
            'timestamp': datetime.now().isoformat(),
            'user': user,
            'data_type': data_type,
            'operation': operation,
            'record_count': record_count,
            'compliance_note': 'GDPR Article 30 - Records of processing activities'
        }

        self.logger.info(json.dumps(data_entry))

    def _get_client_ip(self) -> str:
        """è·å–å®¢æˆ·ç«¯IP"""
        # å®ç°è·å–å®¢æˆ·ç«¯IPçš„é€»è¾‘
        return "127.0.0.1"

    def _get_user_agent(self) -> str:
        """è·å–ç”¨æˆ·ä»£ç†"""
        # å®ç°è·å–ç”¨æˆ·ä»£ç†çš„é€»è¾‘
        return "TestFramework/1.0"

    def _get_system_info(self) -> Dict:
        """è·å–ç³»ç»Ÿä¿¡æ¯"""
        return {
            'hostname': socket.gethostname(),
            'platform': platform.platform(),
            'python_version': platform.python_version()
        }

# å®¡è®¡è£…é¥°å™¨
def audit_action(action: str, resource: str = None):
    """å®¡è®¡æ“ä½œè£…é¥°å™¨"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            user = os.getenv('CURRENT_USER', 'system')
            resource_name = resource or func.__name__

            try:
                result = func(*args, **kwargs)
                audit_logger.log_user_action(user, action, resource_name, 'SUCCESS')
                return result
            except Exception as e:
                audit_logger.log_user_action(user, action, resource_name, f'FAILED: {str(e)}')
                raise
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
audit_logger = AuditLogger()

@audit_action('EXECUTE_TEST', 'test_suite')
def execute_test_suite(test_file: str):
    # æ‰§è¡Œæµ‹è¯•é€»è¾‘
    pass
        '''

    def data_retention_policy(self) -> str:
        """æ•°æ®ä¿ç•™ç­–ç•¥"""
        return '''
class DataRetentionManager:
    """æ•°æ®ä¿ç•™ç®¡ç†å™¨"""

    def __init__(self):
        self.retention_policies = {
            'test_results': 90,      # 90å¤©
            'audit_logs': 2555,      # 7å¹´ï¼ˆåˆè§„è¦æ±‚ï¼‰
            'user_data': 1095,       # 3å¹´
            'system_logs': 30,       # 30å¤©
            'performance_metrics': 365  # 1å¹´
        }

    def cleanup_expired_data(self):
        """æ¸…ç†è¿‡æœŸæ•°æ®"""
        current_time = datetime.now()

        for data_type, retention_days in self.retention_policies.items():
            cutoff_date = current_time - timedelta(days=retention_days)

            try:
                deleted_count = self._delete_data_before_date(data_type, cutoff_date)

                if deleted_count > 0:
                    audit_logger.log_system_event(
                        'DATA_CLEANUP',
                        f'åˆ é™¤ {data_type} æ•°æ® {deleted_count} æ¡ï¼Œæˆªæ­¢æ—¥æœŸ: {cutoff_date}',
                        'INFO'
                    )

            except Exception as e:
                audit_logger.log_system_event(
                    'DATA_CLEANUP_ERROR',
                    f'æ¸…ç† {data_type} æ•°æ®å¤±è´¥: {str(e)}',
                    'ERROR'
                )

    def _delete_data_before_date(self, data_type: str, cutoff_date: datetime) -> int:
        """åˆ é™¤æŒ‡å®šæ—¥æœŸå‰çš„æ•°æ®"""
        # æ ¹æ®æ•°æ®ç±»å‹å®ç°å…·ä½“çš„åˆ é™¤é€»è¾‘
        if data_type == 'test_results':
            return self._cleanup_test_results(cutoff_date)
        elif data_type == 'audit_logs':
            return self._cleanup_audit_logs(cutoff_date)
        # ... å…¶ä»–æ•°æ®ç±»å‹

        return 0

    def _cleanup_test_results(self, cutoff_date: datetime) -> int:
        """æ¸…ç†æµ‹è¯•ç»“æœ"""
        # å®ç°æµ‹è¯•ç»“æœæ¸…ç†é€»è¾‘
        pass

    def _cleanup_audit_logs(self, cutoff_date: datetime) -> int:
        """æ¸…ç†å®¡è®¡æ—¥å¿—"""
        # æ³¨æ„ï¼šå®¡è®¡æ—¥å¿—é€šå¸¸æœ‰æ›´é•¿çš„ä¿ç•™æœŸ
        # éœ€è¦ç¬¦åˆæ³•è§„è¦æ±‚
        pass
        '''
````

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v2.0
**æœ€åæ›´æ–°ï¼š** 2024 å¹´ 12 æœˆ
**ç»´æŠ¤è€…ï¼š** è‡ªåŠ¨åŒ–æµ‹è¯•å›¢é˜Ÿ
**è”ç³»æ–¹å¼ï¼š** test-team@company.com
